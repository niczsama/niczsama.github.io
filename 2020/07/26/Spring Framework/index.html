<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring Framework | o.0</title><meta name="author" content="NicZSAMA"><meta name="copyright" content="NicZSAMA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring Framework​        Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。  组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：  Core Container    由 s">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Framework">
<meta property="og:url" content="http://gakkisama.com/2020/07/26/Spring%20Framework/index.html">
<meta property="og:site_name" content="o.0">
<meta property="og:description" content="Spring Framework​        Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。  组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：  Core Container    由 s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200726232916.png">
<meta property="article:published_time" content="2020-07-26T15:24:42.214Z">
<meta property="article:modified_time" content="2020-08-28T06:36:28.644Z">
<meta property="article:author" content="NicZSAMA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200726232916.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gakkisama.com/2020/07/26/Spring%20Framework/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-08-28 14:36:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210814135458.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200726232916.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">o.0</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring Framework</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-26T15:24:42.214Z" title="发表于 2020-07-26 23:24:42">2020-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-28T06:36:28.644Z" title="更新于 2020-08-28 14:36:28">2020-08-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Framework"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h1><p>​        Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200726232832.png" alt="Spring—架构图- Louis - OSCHINA"></p>
<p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<blockquote>
<p>Core Container</p>
</blockquote>
<p>  由 spring-core, spring-beans, spring-context, springcontext-support, 和 spring-expression (Spring Expression Language) 模块组成。</p>
<ul>
<li><p>Spring-core和spring-beans提供了 Spring 框架的基本功能，包括控制反转（Inversion of Control，简称IoC）和依赖注入（Dependency Injection简称DI）的特性。核心容器的主要组件是 <code>BeanFactory</code>，它是工厂模式的实现。<code>BeanFactory</code>将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p>
</li>
<li><p>spring-context是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</p>
</li>
<li><p>spring-expression主要提供了spring的表达式语言（Expression Language），它是对标准EL的扩展。</p>
</li>
</ul>
<blockquote>
<p>AOP and Instrumentation</p>
</blockquote>
<ul>
<li><p>Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。</p>
</li>
<li><p>单独的spring-aspects模块用来支持与AspectJ的集成。</p>
</li>
<li><p>spring-instrument模块提供在特定的应用程序服务器中类仪器支持和类加载器实现。</p>
</li>
</ul>
<blockquote>
<p>Messaging</p>
</blockquote>
<ul>
<li> Spring Framework 4引入的，主要用来实现基于消息（message）的应用程序开发。</li>
</ul>
<blockquote>
<p>Data Access/Integration</p>
</blockquote>
<ul>
<li><p>该层包括JDBC, ORM, OXM, JMS, and Transaction等模块，主要实现与持久层（如数据库）的连接及事务的控制，如spring-jdbc、spring-tx、spring-orm、spring-oxm、spring-jms。</p>
</li>
<li><p>从Spring Framework 4.1开始，spring-jms支持与spring-messaging进行集成。</p>
</li>
</ul>
<blockquote>
<p>Web</p>
</blockquote>
<ul>
<li><p>Web部分包括spring-web, spring-webmvc, spring-websocket, and springwebmvc-portlet几个模块。</p>
</li>
<li><p>spring-web模块提供了基本的面向web的开发特性，如多文件上传功能、通过Servlet监听和基于web的应用程序上下文初始化IoC等。</p>
</li>
<li><p>spring-webmvc包括Spring MVC模型及Web应用开发中REST风格的Web Service实现。</p>
</li>
<li><p>spring-webmvc-portlet提供了门户导入的组件信息支持，注意ModelAndView在该包和webmvc包都存在，在使用SpringMVC时需要注意，不用引入错了。</p>
</li>
</ul>
<blockquote>
<p>Test</p>
</blockquote>
<ul>
<li><p>Spring测试功能模块支持。</p>
</li>
<li><p>Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。</p>
</li>
</ul>
<h2 id="IOC-容器的初始化过程"><a href="#IOC-容器的初始化过程" class="headerlink" title="IOC 容器的初始化过程"></a>IOC 容器的初始化过程</h2><h3 id="容器的高层视图"><a href="#容器的高层视图" class="headerlink" title="容器的高层视图"></a>容器的高层视图</h3><p>Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配号Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200726235650.png" alt="spring ioc aop | yswape"></p>
<h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><ul>
<li>实际的构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//super方法为容器设置好Bean资源加载器</span></span><br><span class="line">    <span class="comment">//该方法最终会调用到AbstractApplicationContext的无参构造方法</span></span><br><span class="line">    <span class="comment">//这里会默认设置解析路径的模式为Ant-style</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">//设置Bean定义资源文件的路径</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">//调用容器的refresh，载入BeanDefinition的入口</span></span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>refresh()方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		<span class="comment">// 初始化属性配置文件、检验必须属性以及监听器</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		<span class="comment">// 给beanFactory设置序列化id</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">		<span class="comment">// 向beanFactory中注册了两个BeanPostProcessor,以及三个和环境相关的bean</span></span><br><span class="line">		<span class="comment">// 这两个后置处理器为ApplicationContextAwareProcessor和ApplicationListenerDetector</span></span><br><span class="line">		<span class="comment">// 前一个后置处理是为实现了ApplicationContextAware接口的类，回调setApplicationContext()方法，</span></span><br><span class="line">		<span class="comment">// 后一个处理器时用来检测ApplicationListener类的，当某个Bean实现了ApplicationListener接口的bean被创建好后，会被加入到监听器列表中</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			<span class="comment">// 空方法，由子类实现</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">			<span class="comment">// 执行所有的BeanFactoryPostProcessor，包括自定义的，以及spring内置的。默认情况下，容器中只有一个BeanFactoryPostProcessor,即：Spring内置的，ConfigurationClassPostProcessor(这个类很重要)</span></span><br><span class="line">			<span class="comment">// 会先执行实现了BeanDefinitionRegistryPostProcessor接口的类，然后执行BeanFactoryPostProcessor的类</span></span><br><span class="line">			<span class="comment">// ConfigurationClassPostProcessor类的postProcessorBeanFactory()方法进行了@Configuration类的解析，@ComponentScan的扫描，以及@Import注解的处理</span></span><br><span class="line">			<span class="comment">// 经过这一步以后,会将所有交由spring管理的bean所对应的BeanDefinition放入到beanFactory的beanDefinitionMap中</span></span><br><span class="line">			<span class="comment">// 同时ConfigurationClassPostProcessor类的postProcessorBeanFactory()方法执行完后，向容器中添加了一个后置处理器————ImportAwareBeanPostProcessor</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">			<span class="comment">// 注册所有的BeanPostProcessor，因为在方法里面调用了getBean()方法，所以在这一步，实际上已经将所有的BeanPostProcessor实例化了</span></span><br><span class="line">            <span class="comment">// 为什么要在这一步就将BeanPostProcessor实例化呢？因为后面要实例化bean，而BeanPostProcessor是用来干预bean的创建过程的，所以必须在bean实例化之前就实例化所有的BeanPostProcessor(包括开发人员自己定义的)</span></span><br><span class="line">			<span class="comment">// 最后再重新注册了ApplicationListenerDetector，这样做的目的是为了将ApplicationListenerDetector放入到后置处理器的最末端</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">           <span class="comment">// 初始化MessageSource，用来做消息国际化。在一般项目中不会用到消息国际化</span></span><br><span class="line">			initMessageSource();</span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			<span class="comment">// 初始化事件广播器，如果容器中存在了名字为applicationEventMulticaster的广播器，则使用该广播器</span></span><br><span class="line">			<span class="comment">// 如果没有，则初始化一个SimpleApplicationEventMulticaster</span></span><br><span class="line">            <span class="comment">// 事件广播器的用途是，发布事件，并且为所发布的时间找到对应的事件监听器。</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			<span class="comment">// 执行其他的初始化操作，例如和SpringMVC整合时，需要初始化一些其他的bean，但是对于纯spring工程来说，onRefresh方法是一个空方法</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			<span class="comment">// 这一步会将自定义的listener的bean名称放入到事件广播器中</span></span><br><span class="line">			<span class="comment">// 同时还会将早期的ApplicationEvent发布(对于单独的spring工程来说，在此时不会有任何ApplicationEvent发布，但是和springMVC整合时，springMVC会执行onRefresh()方法，在这里会发布事件)</span></span><br><span class="line">			registerListeners();</span><br><span class="line">			<span class="comment">// 实例化剩余的非懒加载的单例bean(注意：剩余、非懒加载、单例)</span></span><br><span class="line">            <span class="comment">// 为什么说是剩余呢？如果开发人员自定义了BeanPosrProcessor，而BeanPostProcessor在前面已经实例化了，所以在这里不会再实例化，因此这里使用剩余一词</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">			<span class="comment">// 结束refresh，主要干了一件事，就是发布一个事件ContextRefreshEvent，通知大家spring容器refresh结束了。</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="comment">// 出异常后销毁bean</span></span><br><span class="line">			destroyBeans();</span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 在bean的实例化过程中，会缓存很多信息，例如bean的注解信息，但是当单例bean实例化完成后，这些缓存信息已经不会再使用了，所以可以释放这些内存资源了</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>初始化容器环境变量和系统属性</li>
<li>初始化 BeanFactory ，并读取 xml 文件</li>
<li>设置 BeanFactoryPostProcessor 后置处理器</li>
<li>调用 BeanFactoryPostProcessor</li>
<li>注册 BeanPostProcessors</li>
<li>为上下文初始化 Message 源</li>
<li>初始化应用消息广播器</li>
<li>实例化剩余的非懒加载的单例 Bean</li>
<li>发布一个 ContextRefreshEvent 事件，通知容器 refresh 结束</li>
<li>释放资源</li>
</ol>
<h2 id="Spring-IoC-容器核心组件"><a href="#Spring-IoC-容器核心组件" class="headerlink" title="Spring IoC 容器核心组件"></a>Spring IoC 容器核心组件</h2><h3 id="ApplicationContext-和ApplicationContext-XML"><a href="#ApplicationContext-和ApplicationContext-XML" class="headerlink" title="ApplicationContext 和ApplicationContext.XML"></a>ApplicationContext 和ApplicationContext.XML</h3><p>ApplicationContext是所有应用上下文的父接口，其也继承了BeanFactory的相关接口，简单来说也是一个Bean工厂，所以ApplicationContext中可以有一些列的Bean操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">		<span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用Spring的时候，一般来说都会通过这个方式来实例化一个<code>applicationContext</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoOperationMain</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		ApplicationContext appCtx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>ApplicationContext应用上下文体系如下：</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727145607.png"></p>
<p>在实现类ClassPathXmlApplicationContext中其实并没有多少重要的操作，主要是在构造函数中配置Spring配置文件的路径：<br>具体的applicationContext.xml解析相关的操作都在父类refresh中进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> <span class="built_in">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath*:applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>





<h3 id="BeanFactoryPostProcessor-和-BeanPostProcessor"><a href="#BeanFactoryPostProcessor-和-BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcessor 和 BeanPostProcessor"></a>BeanFactoryPostProcessor 和 BeanPostProcessor</h3><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor接口的作用是在Spring容器完成Bean实例化前后可以添加一些自己的逻辑处理，我们可以定义一个或者多个BeanPostProcessor接口的实现。</p>
<p>BeanPostProcessor接口提供了两个方法：</p>
<ol>
<li><p>postProcessBeforeInitialization  可以对Bean在实例化之前添加一些逻辑处理</p>
</li>
<li><p>postProcessAfterInitialization  可以对bean在实例化之后添加一些逻辑处理</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//可以对Bean在实例化之前添加一些逻辑处理</span></span><br><span class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//可以对bean在实例化之后添加一些逻辑处理</span></span><br><span class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单示例MyBeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Bean 实例化之前进行的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;对象&quot;</span> + beanName + <span class="string">&quot;开始实例化&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Bean 实例化之后进行的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;对象&quot;</span> + beanName + <span class="string">&quot;实例化完成&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在applicationContext.xml中添加配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.spring.test.di.MyBeanPostProcessor&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>



<blockquote>
<h4 id="BeanPostProcessor保存到Spring容器"><a href="#BeanPostProcessor保存到Spring容器" class="headerlink" title="BeanPostProcessor保存到Spring容器"></a>BeanPostProcessor保存到Spring容器</h4></blockquote>
<p>这样MyBeanPostProcessor就会添加到Spring的容器中，在Spring容器中会将所有实现BeanPostProcessor的bean保存起来，具体实现在AbstractApplicationContext的registerBeanPostProcessors中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取所有实现BeanPostProcessor的实现类</span></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"> </span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				<span class="comment">//保存所有的BeanPostProcessor</span></span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		OrderComparator.sort(priorityOrderedPostProcessors);</span><br><span class="line">		<span class="comment">//注册所有的BeanPostProcessor</span></span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"> </span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		OrderComparator.sort(orderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"> </span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"> </span><br><span class="line">		OrderComparator.sort(internalPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"> </span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在容器中添加BeanPostProcessor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<h4 id="执行所有的BeanPostProcessor"><a href="#执行所有的BeanPostProcessor" class="headerlink" title="执行所有的BeanPostProcessor"></a>执行所有的BeanPostProcessor</h4></blockquote>
<p>在Spring容器在初始化Bean前后都会执行所有的BeanPostProcessor的实现类提供的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> </span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		<span class="comment">//getBeanPostProcessors()获取所有的BeanPostProcessor的实现类</span></span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="comment">//执行BeanPostProcessor实现类的方法</span></span><br><span class="line">			result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727151559.png"></p>
<h4 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h4><p>和BeanPostProcessor原理一致，Spring提供了对BeanFactory进行操作的处理器BeanFactoryProcessor，简单来说就是获取容器BeanFactory，这样就可以在真正初始化bean之前对bean做一些处理操作。<br>BeanFactoryPostProcessor接口源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取beanFactory，这样在真正使用容器之前可以对一些bean做一些初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//获取BeanDefinition </span></span><br><span class="line">        GenericBeanDefinition rootBeanDefinition = (GenericBeanDefinition) beanFactory.getBeanDefinition(<span class="string">&quot;transaction&quot;</span>);</span><br><span class="line">        <span class="comment">//将bean设置出延迟初始化</span></span><br><span class="line">        rootBeanDefinition.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">        System.err.println(rootBeanDefinition.getInitMethodName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>示例的功能是在bean初始化之前修改bean的属性配置。<br>接下来我们介绍一下BeanFactoryPostProcessor的初始化和调用机制。<br>（1）BeanFactoryPostProcessor和普通的bean一样注册到spring容器中。<br>（2）获取所有的BeanFactoryPostProcessor类型的类并初始化，添加到列表中<br>（3）在列表中循环执行所有的BeanFactoryPostProcessor实现类。</p>
<p>起始执行点在AbstractApplicationContext中，invokeBeanFactoryPostProcessors(beanFactory)执行是在初始化Bean实体方法finishBeanFactoryInitialization(beanFactory)之前，这样就可以在初始化bean之前可以对一些bean做一些额外的处理操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>

<p>执行BeanFactoryPostProcessor所有的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行BeanFactoryPostProcessor所有的实现类</span></span><br><span class="line">        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">        <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors方法中如下操作</p>
<p>获取所有BeanFactoryPostProcessor的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>



<p>从Spring的容器中获取所有的BeanFactoryPostProcessor实现类，添加到priorityOrderedPostProcessors 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">        List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">                <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">//从Spring的容器中获取所有的BeanFactoryPostProcessor实现类，添加到priorityOrderedPostProcessors 中</span></span><br><span class="line">                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>执行所有的BeanFactoryPostProcessor的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br></pre></td></tr></table></figure>



<p>遍历执行所有的BeanFactoryPostProcessor的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">            postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="BeanFactory-和-FactoryBean"><a href="#BeanFactory-和-FactoryBean" class="headerlink" title="BeanFactory 和 FactoryBean"></a>BeanFactory 和 FactoryBean</h3><p>Spring中有两种类型的Bean：一种是普通的JavaBean；另一种就是工厂Bean（FactoryBean），这两种Bean都受Spring的IoC容器管理，但它们之间却有一些区别。</p>
<h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>FactoryBean跟普通Bean不同，它是实现了FactoryBean<T>接口的Bean，通过BeanFactory类的getBean方法直接获取到的并不是该FactoryBean的实例，而是该FactoryBean中方法getObject返回的对象。但我们可以通过其它途径获取到该FactoryBean的实例，方法就是在通过getBean方法获取实例时在参数name前面加上“&amp;”符号即可。</p>
<p>FactoryBean接口提供的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//获取FactoryBean初始化的Bean实例</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">//获取Bean实例的类型</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="comment">//判断是否是单例模式</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建一个示例：MyFactoryBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Date</span>&gt;,<span class="title">BeanNameAware</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;  </span><br><span class="line">        <span class="keyword">return</span> Date.class;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;My name is &quot;</span> + <span class="keyword">this</span>.name);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在Spring的配置文件ApplicationContext.xml中注入MyFactoryBean</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id =&quot;myFactoryBean&quot; class=&quot;com.xxxx.MyFactoryBean&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFactoryBean</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;  </span><br><span class="line">		ApplicationContext appCtx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">	    Date now = (Date) appCtx.getBean(<span class="string">&quot;myFactoryBean&quot;</span>);  </span><br><span class="line">	    System.out.println(now);  </span><br><span class="line">	    MyFactoryBean factoryBean = (MyFactoryBean) appCtx.getBean(<span class="string">&quot;&amp;myFactoryBean&quot;</span>);  </span><br><span class="line">	    factoryBean.sayName();  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果：通过myFactoryBean名称获取到的Bean是Date对象实例，通过&amp;myFactoryBean获取到的是MyFactoryBean对象实例。</p>
<p>实现原理：</p>
<p>我们来看一下执行Date now = (Date) appCtx.getBean(“myFactoryBean”);  时会做的处理操作。</p>
<p>AbstractBeanFactory中会进行一系列的操作。</p>
<p>getBean获取bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>doGetBean中获取bean实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		.........<span class="comment">//省略部分代码</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		.........<span class="comment">//省略部分代码</span></span><br><span class="line">		<span class="keyword">return</span> (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>getObjectForBeanInstance中会选择bean实例是普通的Bean还是FactoryBean，同时通过判断name中是否有&amp;来选择判断是或者FactoryBean还是其getObject方法中获取的bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		.........<span class="comment">//省略部分代码</span></span><br><span class="line">		<span class="comment">//判断bean类型是否是FactoryBean，或者name是否是以&amp;开头，如果是则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果是则从getObjectFromFactoryBean中获取</span></span><br><span class="line">		<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">			<span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">			object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>getObjectFromFactoryBean接下来会执行FactoryBean的getObject方法获取bean了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">		.........<span class="comment">//省略部分代码				</span></span><br><span class="line">		Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">		.........<span class="comment">//省略部分代码</span></span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">		Object object;</span><br><span class="line">		.........<span class="comment">//省略部分代码</span></span><br><span class="line">		<span class="comment">//调用Factory的getObject方法</span></span><br><span class="line">		object = factory.getObject();</span><br><span class="line">		.........<span class="comment">//省略部分代码</span></span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>总结：Spring对FactoryBean的实现机制是当你获取一个Bean时，如果获取的Bean的类型是FactoryBean，并且其name中并没有&amp;则调用bean的getObject方法获取FactoryBean实现类中提供bean，否则就是直接返回普通的bean类型。</p>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory及其子类是Spring IOC容器中最重要的一个类，BeanFactory由类名可以看出其是一个Bean工厂类，其实它确实是一个Bean工厂类，完成Bean的初始化操作。Bean的初始化操作还是一个比较麻烦的操作，首先根据spring注入配置将bean初始化为单例或者原型，其次需要根据Bean的属性配置来完成Bean参数的注入配置，还有要解决单例模式下Bean的循环依赖的问题，原型模式下bean的循环依赖会直接报错。</p>
<p>BeanFactory接口及其实现类：</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727152938.png"></p>
<p>BeanFactory接口继承关系:</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727153005.png"></p>
<p>BeanFactory 是Spring bean容器的根接口.提供获取bean,是否包含bean,是否单例与原型,获取bean类型,bean 别名的api.</p>
<ul>
<li><p>AutowireCapableBeanFactory 添加集成其他框架功能.如果集成WebWork则可以使用Spring对Actions等进行管理.</p>
</li>
<li><p>HierarchicalBeanFactory 提供父容器的访问功能</p>
</li>
<li><p>ConfigurableBeanFactory 如名,提供factory的配置功能,眼花缭乱好多api</p>
</li>
<li><p>ConfigurableListableBeanFactory 集大成者,提供解析,修改bean定义,并与初始化单例.</p>
</li>
<li><p>ListableBeanFactory 提供容器内bean实例的枚举功能.这边不会考虑父容器内的实例.</p>
</li>
</ul>
<p>BeanFactory提供的接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//根据名称获取bean</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//根据名称及类型获取类</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//根据类型获取类</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//单例判断</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="comment">//原型判断</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="comment">//类型判断</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"> </span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"> </span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="BeanDefinition-和-BeanDefinitionHolder"><a href="#BeanDefinition-和-BeanDefinitionHolder" class="headerlink" title="BeanDefinition 和 BeanDefinitionHolder"></a>BeanDefinition 和 BeanDefinitionHolder</h3><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p> BeanDefinition描述了一个bean实例，拥有属性值、构造参数值和具体实现的其他信息，其是一个bean的元数据，xml中配置的bean元素会被解析成BeanDefinition对象。</p>
<p>BeanDefinition的接口的结构类图:</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727153216.png"></p>
<ul>
<li><p>ChildBeanDefinition</p>
<p>​        可以让子Bean定义拥有从父母哪里继承配置的能力。相应的，子Bean定义有一个固定的依赖–他们的父bean定义。</p>
<p>​        一个子bean定义将继承父母的构造参数值、属性值和方法覆盖并且可以选择的增加新的值。 如果初始化方法、销毁方法或者静态工厂方法已经指定了，那么将覆盖父bean定义中的相关配置。 子bean定义保留的配置将是：依赖、自动装配模式、依赖检查、单例和延迟加载。</p>
</li>
</ul>
<p>==注意: 自从Spring 2.5之后, 编程的方式注册bean定义的优选方法是使用 GenericBeanDefinition类, 允许使用GenericBeanDefinition.setParentName方法动态的定义父依赖。 在大多数场景下可以 有效的取代ChildBeanDefinition类。==</p>
<ul>
<li><p>GenericBeanDefinition</p>
<p>​        GenericBeanDefinition是一个定义标准的bean定义的一站式服务。</p>
<p>​        像任何Bean定义，它允许指定一个类、可选的构造参数值和属性值。 除此之外可以通过配置”parentName”属性来灵活地指定从一个父Bean定义中派生。<br>​        通常来说，使用GenericBeanDefinition类为了注册一个用户可见的bean定义(后置处理器可能会操作它， 甚至可能重新配置父母的名字)。如果父/子关系是预设的建议使用RootBeanDefinition / ChildBeanDefinition。</p>
</li>
</ul>
<ul>
<li><p>RootBeanDefinition</p>
<p>​        RootBeanDefinition描述了Spring BeanFactory运行时合并后的特定Bean定义。</p>
<p>​        它可能来源于多个原始Bean定义(继承自其他的bean定义，通常被注册为GenericBeanDefinitions)。RootBeanDefinition从本质上将是运行时统一的Bean定义视图。<br>​        在配置阶段，RootBeanDefinition也可能用于注册独立的bean定义。然而，自从Spring2.5依赖，编程地注册bean定义建议使用 GenericBeanDefinition类。GenericBeanDefinition在允许动态定义父依赖而不是硬编码作为RootBeanDefinition方面有优势。</p>
</li>
</ul>
<p>在抽象类AbstractBeanDefinition中添加了更多和bean属性设置相关的处理操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCOPE_DEFAULT = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_NONE = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_OBJECTS = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_SIMPLE = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_ALL = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFER_METHOD = <span class="string">&quot;(inferred)&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Object beanClass;</span><br><span class="line">	<span class="keyword">private</span> String scope = SCOPE_DEFAULT;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> abstractFlag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> autowireMode = AUTOWIRE_NO;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> dependencyCheck = DEPENDENCY_CHECK_NONE;</span><br><span class="line">	<span class="keyword">private</span> String[] dependsOn;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> autowireCandidate = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> primary = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers =</span><br><span class="line">			<span class="keyword">new</span> LinkedHashMap&lt;String, AutowireCandidateQualifier&gt;(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> nonPublicAccessAllowed = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> lenientConstructorResolution = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> ConstructorArgumentValues constructorArgumentValues;</span><br><span class="line">	<span class="keyword">private</span> MutablePropertyValues propertyValues;</span><br><span class="line">	<span class="keyword">private</span> MethodOverrides methodOverrides = <span class="keyword">new</span> MethodOverrides();</span><br><span class="line">	<span class="keyword">private</span> String factoryBeanName;</span><br><span class="line">	<span class="keyword">private</span> String factoryMethodName;</span><br><span class="line">	<span class="keyword">private</span> String initMethodName;</span><br><span class="line">	<span class="keyword">private</span> String destroyMethodName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> enforceInitMethod = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> enforceDestroyMethod = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> synthetic = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> role = BeanDefinition.ROLE_APPLICATION;</span><br><span class="line">	<span class="keyword">private</span> String description;</span><br><span class="line">	<span class="keyword">private</span> Resource resource;</span><br><span class="line">	</span><br><span class="line">	.........<span class="comment">//属性处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BeanDefinition源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">	String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line">	<span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line">	<span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line">	String[] getDependsOn();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(String... dependsOn)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line">	<span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BeanDefinitionHolder"><a href="#BeanDefinitionHolder" class="headerlink" title="BeanDefinitionHolder"></a>BeanDefinitionHolder</h4><p>BeanDefinitionHolder 就是一个 BeanDefinition 的持有者，其定义了一下变量，并对以下变量提供 get 和 set 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br></pre></td></tr></table></figure>



<p>BeanDefinitionHolder 的源码中都是有关这几个变量的 get 和 set 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinition beanDefinition, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(beanDefinition, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinition beanDefinition, String beanName, String[] aliases)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line">		Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.beanDefinition = beanDefinition;</span><br><span class="line">		<span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">		<span class="keyword">this</span>.aliases = aliases;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(beanDefinitionHolder, <span class="string">&quot;BeanDefinitionHolder must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.beanDefinition = beanDefinitionHolder.getBeanDefinition();</span><br><span class="line">		<span class="keyword">this</span>.beanName = beanDefinitionHolder.getBeanName();</span><br><span class="line">		<span class="keyword">this</span>.aliases = beanDefinitionHolder.getAliases();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBeanName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanName;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] getAliases() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.aliases;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition.getSource();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchesName</span><span class="params">(String candidateName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (candidateName != <span class="keyword">null</span> &amp;&amp; (candidateName.equals(<span class="keyword">this</span>.beanName) ||</span><br><span class="line">				candidateName.equals(BeanFactoryUtils.transformedBeanName(<span class="keyword">this</span>.beanName)) ||</span><br><span class="line">				ObjectUtils.containsElement(<span class="keyword">this</span>.aliases, candidateName)));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getShortDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		sb.append(<span class="string">&quot;Bean definition with name &#x27;&quot;</span>).append(<span class="keyword">this</span>.beanName).append(<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">			sb.append(<span class="string">&quot; and aliases [&quot;</span>).append(StringUtils.arrayToCommaDelimitedString(<span class="keyword">this</span>.aliases)).append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLongDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(getShortDescription());</span><br><span class="line">		sb.append(<span class="string">&quot;: &quot;</span>).append(<span class="keyword">this</span>.beanDefinition);</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getLongDescription();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == other) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(other <span class="keyword">instanceof</span> BeanDefinitionHolder)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		BeanDefinitionHolder otherHolder = (BeanDefinitionHolder) other;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition.equals(otherHolder.beanDefinition) &amp;&amp;</span><br><span class="line">				<span class="keyword">this</span>.beanName.equals(otherHolder.beanName) &amp;&amp;</span><br><span class="line">				ObjectUtils.nullSafeEquals(<span class="keyword">this</span>.aliases, otherHolder.aliases);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> hashCode = <span class="keyword">this</span>.beanDefinition.hashCode();</span><br><span class="line">		hashCode = <span class="number">29</span> * hashCode + <span class="keyword">this</span>.beanName.hashCode();</span><br><span class="line">		hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.aliases);</span><br><span class="line">		<span class="keyword">return</span> hashCode;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Spring-Bean-生命周期及循环引用"><a href="#Spring-Bean-生命周期及循环引用" class="headerlink" title="Spring Bean 生命周期及循环引用"></a>Spring Bean 生命周期及循环引用</h2><h3 id="Bean-对象初始化"><a href="#Bean-对象初始化" class="headerlink" title="Bean 对象初始化"></a>Bean 对象初始化</h3><p>即使我们在不了解Spring对bean的初始化机制，我们也可以根据Java语言的特性猜测到其很有可能是通过反射机制来完成Bean的初始化操作，接下来我们一步一步的剖析Spring对Bean的初始化操作。</p>
<p>首先Spring会通过调用 getBean(String name)来获取Bean，在获取bean的过程中完成的Bean的初始化操作。</p>
<p>AbstractBeanFactory类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>在doGetBean方法中会判断bean的类型单例、原型，如果是单例则需要判断是否已经初始化bean并添加到缓存中，如果是原型bean则需要重新初始化bean，由于Spring对beanName提供了别名机制，所有需要通过beanName获取最终的bean名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//查找name是否有别名，获取最终的beanName</span></span><br><span class="line">		<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//如果bean是单例模式，首先尝试从缓存中获取</span></span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//会判断bean是否是FactoryBean，如果不是直接返回sharedInstance，否则调用sharedInstance.getObject()方法返回bean</span></span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断容器是否有父容器，如果有则首先尝试从父容器中获取</span></span><br><span class="line">			BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">				String nameToLookup = originalBeanName(name);</span><br><span class="line">				<span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">					<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">					<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//根据beanName获取bean的元数据</span></span><br><span class="line">				<span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"> </span><br><span class="line">				<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">				String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">						<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						registerDependentBean(dep, beanName);</span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"> </span><br><span class="line">				<span class="comment">// bean是单例</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">					<span class="comment">//获取bean，首先会暴露一个ObjectFactory，通过调用getObject来调用createBean(beanName, mbd, args)获取bean</span></span><br><span class="line">					sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="comment">//</span></span><br><span class="line">								<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">								destroySingleton(beanName);</span><br><span class="line">								<span class="keyword">throw</span> ex;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					<span class="comment">//会判断bean是否是FactoryBean，如果不是直接返回sharedInstance，否则调用sharedInstance.getObject()方法返回bean</span></span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//bean是原型</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">					<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">					Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="comment">//初始化bean</span></span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span> &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//bean是其他模式</span></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					<span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">					<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">								beforePrototypeCreation(beanName);</span><br><span class="line">								<span class="keyword">try</span> &#123;</span><br><span class="line">									<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">finally</span> &#123;</span><br><span class="line">									afterPrototypeCreation(beanName);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">								<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">								<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略代码..........</span></span><br><span class="line">		<span class="keyword">return</span> (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>接下来我们看看在createBean(String beanName, RootBeanDefinition mbd, Object[] args)中进行的处理操作，在createBean中会通过BeanDefinition中获取类名resolvedClass（反射机制重要的一个参数），并且会调用resolveBeforeInstantiation在bean初始的过程中做一些预处理（简单来说就是BeanPostProcessor的实现类所做的处理操作）。</p>
<p>AbstractAutowireCapableBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//获取类名，通过反射机制来实例化类</span></span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		<span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">			<span class="comment">//设置类名</span></span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Prepare method overrides.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">			<span class="comment">//如果bean想要在初始化后使用之前做一些预处理操作</span></span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//初始化bean</span></span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>doCreateBean中完成的处理操作就比较多了，简单来说调用了几个方法完成了bean的初始化操作：<br>createBeanInstance完成通过构造函数初始化bean的操作；</p>
<p>addSingletonFactory完成将初始化的bean提前暴露出去，这样就解决了单例bean非构造函数的循环引用问题；</p>
<p>populateBean完成bean的属性注入操作，通过set方法或者注解注入属性；</p>
<p>initializeBean完成了bean注入时设置的init-method方法的执行，同时在执行init-method之前会调用applyBeanPostProcessorsBeforeInitialization完成bean使用前的处理操作，调用applyBeanPostProcessorsAfterInitialization完成bean初始化后的操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">		BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">			instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//初始化bean实例</span></span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">		Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//将初始化的bean提前暴露出去，暴露一个ObjectFactory，这也是Spring解决单例bean非构造函数依赖的解决方法</span></span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//初始化bean的各种注入或者setXX参数</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			<span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//调用注入类的init-method方法</span></span><br><span class="line">				exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>createBeanInstance中会通过bean的构造函数或者默认构造函数来完成bean的初始化工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//省略代码.............</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">			<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">				<span class="comment">//通过构造函数初始化</span></span><br><span class="line">				<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//使用默认构造函数初始化</span></span><br><span class="line">				<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Need to determine the constructor...</span></span><br><span class="line">		Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">		<span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">		<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>instantiateBean中会调用bean初始策略InstantiationStrategy的实现类完成bean的初始化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object beanInstance;</span><br><span class="line">			<span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//调用bean初始化策InstantiationStrategy略初始化bean</span></span><br><span class="line">				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">			&#125;</span><br><span class="line">			BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">			initBeanWrapper(bw);</span><br><span class="line">			<span class="keyword">return</span> bw;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>调用InstantiationStrategy的instantiate方法完成初始化操作。</p>
<p>SimpleInstantiationStrategy（InstantiationStrategy实现类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line">		<span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">			Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">			<span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">				constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">				<span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">					<span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">							constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">								<span class="meta">@Override</span></span><br><span class="line">								<span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">									<span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							constructorToUse =	clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//最终在BeanUtils中完成bean的初始化操作</span></span><br><span class="line">			<span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">			<span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>最终我们发现bean的初始化操作是在BeanUtils中完成的，通过反射机制完成Bean的初始化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">		Assert.notNull(ctor, <span class="string">&quot;Constructor must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">			<span class="comment">//通过反射机制初始化bean</span></span><br><span class="line">			<span class="keyword">return</span> ctor.newInstance(args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is it an abstract class?&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is the constructor accessible?&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Illegal arguments for constructor&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Bean对象变量初始化"><a href="#Bean对象变量初始化" class="headerlink" title="Bean对象变量初始化"></a>Bean对象变量初始化</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>​        对于Spring对属性值注入的方式，即使我们没有看Spring的实现方式可能也会猜到，对于通过set方法注入的变量值简单来说调用类的xx.xx.setXx(args ..)就完成了变量值的注入操作，对于通过注解@Autowired注入的对象，可以通过Java提供的反射机制通过获取Field对象来获取变量值，通过调用Field.set(Object obj, Object value)方法来完成变量的初始化工作，实际上Spring就是通过Java最基本的反射机制来完成变量值注入的（对于Java反射机制的了解参考Java反射机制）。</p>
<pre><code>  首先在AbstractAutowireCapableBeanFactory的populateBean方法中首先会获取所有要注入的变量值设置，包括在xml中配置的property属性，通过@Autowired注释的变量以及提供了setXxx方法的变量值都会被收集为MutablePropertyValues对象
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取要设置的属性值</span></span><br><span class="line">		PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">						continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//通过名称来注入bean</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">				autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//通过类型来注入bean</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">				autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			pvs = newPvs;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">		<span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">			<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">				<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">					<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">						<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">				checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//对MutablePropertyValues注入属性</span></span><br><span class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>applyPropertyValues方法中要开始尝试对属性值做注入处理，但是在注入处理之前做一些预处理操作，简单来说对参数值做了深拷贝处理（具体问什么这么做还不知），接下来是调用BeanWrapper.setPropertyValues方法做参数值注入处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">		List&lt;PropertyValue&gt; original;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">				((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">			mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">			<span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">				<span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bw.setPropertyValues(mpvs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">							mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			original = mpvs.getPropertyValueList();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">		<span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">			converter = bw;</span><br><span class="line">		&#125;</span><br><span class="line">		BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">		List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());</span><br><span class="line">		<span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String propertyName = pv.getName();</span><br><span class="line">				Object originalValue = pv.getValue();</span><br><span class="line">				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">				Object convertedValue = resolvedValue;</span><br><span class="line">				<span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">				<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">				<span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">				<span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">					<span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">						pv.setConvertedValue(convertedValue);</span><br><span class="line">					&#125;</span><br><span class="line">					deepCopy.add(pv);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">						!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">						!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">					pv.setConvertedValue(convertedValue);</span><br><span class="line">					deepCopy.add(pv);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">					deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">			mpvs.setConverted();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//调用BeanWrapper的方法做参数值注入处理</span></span><br><span class="line">			bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>在BeanWrapper的setPropertyValues中会循环对每次属性值做注入处理操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues pvs)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		setPropertyValues(pvs, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues pvs, <span class="keyword">boolean</span> ignoreUnknown, <span class="keyword">boolean</span> ignoreInvalid)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> </span><br><span class="line">		List&lt;PropertyAccessException&gt; propertyAccessExceptions = <span class="keyword">null</span>;</span><br><span class="line">		List&lt;PropertyValue&gt; propertyValues = (pvs <span class="keyword">instanceof</span> MutablePropertyValues ?</span><br><span class="line">				((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : propertyValues) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//给属性注入操作</span></span><br><span class="line">				setPropertyValue(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>注入的操作分两种，一种是对有setXxx方法的注入则直接调用BeanPropertyHandler的setValue方法通过反射调用Method.invoke实现注入操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">final</span> Object object, Object valueToApply)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			<span class="comment">//通过使用setXxx方法进行注入</span></span><br><span class="line">			<span class="keyword">final</span> Method writeMethod = (<span class="keyword">this</span>.pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">					((GenericTypeAwarePropertyDescriptor) <span class="keyword">this</span>.pd).getWriteMethodForActualAccess() :</span><br><span class="line">					<span class="keyword">this</span>.pd.getWriteMethod());</span><br><span class="line">			<span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;&amp; !writeMethod.isAccessible()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">							writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">final</span> Object value = valueToApply;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">							writeMethod.invoke(object, value);</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, acc);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> ex.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				writeMethod.invoke(getWrappedInstance(), value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于没有setXxx方法简单来说通过注解方法注释的属性则通过FieldPropertyHandler直接给属性赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object object, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ReflectionUtils.makeAccessible(<span class="keyword">this</span>.field);</span><br><span class="line">				<span class="comment">//操作属性值进行注入</span></span><br><span class="line">				<span class="keyword">this</span>.field.set(object, value);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getWrappedClass(), <span class="keyword">this</span>.field.getName(),</span><br><span class="line">						<span class="string">&quot;Field is not accessible&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>总结：简单来说Spring对属性值的注入方法还是比较简单的，通过Java提供的反射机制，对于有setXxx方法的变量直接通过反射调用方法注入参数值；对于没有setXxx方法的变量则通过Field方法，直接对变量进行赋值操作。</p>
<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727002248.png" alt="img"></p>
<h3 id="Bean-对象循环依赖问题"><a href="#Bean-对象循环依赖问题" class="headerlink" title="Bean 对象循环依赖问题"></a>Bean 对象循环依赖问题</h3><p>循环依赖就是N个类相互嵌套引用，如果通过new对象的方式产生循环依赖的话会导致程序内存溢出报错，接下来我们了解一下spring是如何解决循环依赖问题。</p>
<h4 id="第一种：prototype-原型-bean-循环依赖"><a href="#第一种：prototype-原型-bean-循环依赖" class="headerlink" title="第一种：prototype 原型 bean 循环依赖"></a>第一种：prototype 原型 bean 循环依赖</h4><p>对于原型bean的初始化过程中不论是通过构造器参数循环依赖还是通过setXxx方法产生循环依赖，Spring都会直接报错处理。<br>AbstractBeanFactory.doGetBean()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">		<span class="keyword">return</span> (curVal != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">				(curVal.equals(beanName) || (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>在获取bean之前如果这个原型bean正在被创建则直接抛出异常。原型bean在创建之前会进行标记这个beanName正在被创建，等创建结束之后会删除标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建原型bean之前添加标记</span></span><br><span class="line">		beforePrototypeCreation(beanName);</span><br><span class="line">		<span class="comment">//创建原型bean</span></span><br><span class="line">		prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//创建原型bean之后删除标记</span></span><br><span class="line">		afterPrototypeCreation(beanName);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>==总结：Spring不支持原型bean的循环依赖。==</p>
<h4 id="第二种：单例bean-构造器参数循环依赖"><a href="#第二种：单例bean-构造器参数循环依赖" class="headerlink" title="第二种：单例bean 构造器参数循环依赖"></a>第二种：单例bean 构造器参数循环依赖</h4><p>对于单例bean通过构造器参数进行循环依赖时，Spring也是通过抛出异常进行处理的，接下来我们分析一下其是如何实现。假设这里有两个类ClassA 和 ClassB，两个类通过构造器进行循环依赖。</p>
<ol>
<li>Spring创建ClassA时首先会调用beforeSingletonCreation(beanName)，判断单例bean是否正在被创建，如果正在被创建则报错，如果没有被创建则做标记</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//singletonsCurrentlyInCreation是一个集合，不可重复，add返回true则表明没有创建，返回false则说明bean在创建</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>此时刚开始创建ClassA，因此不会报异常错误，当初始化ClassA的构造器时需要用到ClassB的实例。</p>
<ol start="2">
<li>Spring从容器中无法获取ClassB的实例，接下来Spring按照步骤1创建ClassB的实例，在构造ClassB的构造函数时需要用到ClassA的实例。</li>
<li>Spring还是首先尝试从容器中获取ClassA的实例，由于第1步还没有执行结束，此时还没有ClassA实例，Spring容器认为就需要初始化ClassA了，重复第1步，但是ClassA一开始就已经进行了第1步，并且做标记bean正在创建，当再次进入第一步时就会抛出异常错误。</li>
</ol>
<p>==总结：Spring在创建构造器循环依赖时其实就是循环初始化操作 A-&gt; B -&gt; A  当A要被初始化第二次时就直接抛出异常。==</p>
<h4 id="第三种：单例bean通过setXxx或者-Autowired进行循环依赖"><a href="#第三种：单例bean通过setXxx或者-Autowired进行循环依赖" class="headerlink" title="第三种：单例bean通过setXxx或者@Autowired进行循环依赖"></a>第三种：单例bean通过setXxx或者@Autowired进行循环依赖</h4><p>Spring通过setXxx或者@Autowired方法解决循环依赖其实是通过提前暴露一个ObjectFactory对象来完成的，简单来说ClassA在调用构造器完成对象初始化之后，在调用ClassA的setClassB方法之前就把ClassA实例化的对象通过ObjectFactory提前暴露到Spring容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将初始化后的对象提前已ObjectFactory对象注入到容器中</span></span><br><span class="line">			addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器。</li>
<li>ClassA调用setClassB方法，Spring首先尝试从容器中获取ClassB，此时ClassB不存在Spring容器中。</li>
<li>Spring容器初始化ClassB，同时也会将ClassB提前暴露到Spring容器中</li>
<li>ClassB调用setClassA方法，Spring从容器中获取ClassA ，因为第一步中已经提前暴露了ClassA，因此可以获取到ClassA实例</li>
<li>ClassA通过spring容器获取到ClassB，完成了对象初始化操作。</li>
<li>这样ClassA和ClassB都完成了对象初始化操作，解决了循环依赖问题。</li>
</ol>
<h2 id="Spring-AOP-面向切面"><a href="#Spring-AOP-面向切面" class="headerlink" title="Spring AOP 面向切面"></a>Spring AOP 面向切面</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ol>
<li><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4></li>
</ol>
<p>最简单的解决方案就是使用静态代理模式了，代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingProxy</span> <span class="keyword">implements</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GreetingImpl greetingImpl;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetingProxy</span><span class="params">(GreetingImpl greetingImpl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.greetingImpl = greetingImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        greetingImpl.sayHello(name);</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就用这个 GreetingProxy 去代理 GreetingImpl，下面看看客户端如何来调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Greeting greetingProxy = <span class="keyword">new</span> GreetingProxy(<span class="keyword">new</span> GreetingImpl());</span><br><span class="line">        greetingProxy.sayHello(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ol>
<li><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKDynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Greeting greeting = <span class="keyword">new</span> JDKDynamicProxy(<span class="keyword">new</span> GreetingImpl()).getProxy();</span><br><span class="line">        greeting.sayHello(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==JDK 给我们提供的动态代理只能代理接口，而不能代理没有接口的类==</p>
<ol start="2">
<li><h5 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h5></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibDynamicProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CGLibDynamicProxy instance = <span class="keyword">new</span> CGLibDynamicProxy();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CGLibDynamicProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CGLibDynamicProxy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object target, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = proxy.invokeSuper(target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Greeting greeting = CGLibDynamicProxy.getInstance().getProxy(GreetingImpl.class);</span><br><span class="line">        greeting.sayHello(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="AOP-代理工厂-AopProxyFactory"><a href="#AOP-代理工厂-AopProxyFactory" class="headerlink" title="AOP 代理工厂 AopProxyFactory"></a>AOP 代理工厂 AopProxyFactory</h3><p>Spring AOP提供了Aop代理类的工厂类AopProxyFactory，其作用就是创建AopProxy类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Aop工厂，创建AOP</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//创建AOP</span></span><br><span class="line">	<span class="function">AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AopProxyFactory会创建两种代理类：</p>
<ol>
<li><p>jdk提供接口实现的JdkDynamicAopProxy</p>
</li>
<li><p>cglib提供接口实现的ObjenesisCglibAopProxy</p>
</li>
</ol>
<p>​        在Spring配置文件中配置&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;时会默认创建ObjenesisCglibAopProxy，如果没有配置的话就需要根据被代理类是否有接口来选择判断了，如果被代理类由接口则选择使用JdkDynamicAopProxy，否则使用ObjenesisCglibAopProxy，这样选择的原因是由于jdk和cglib实现代理的机制不同来决定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//Spring提供了两种代理类创建方式jdk动态代理和cglib动态代理</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="comment">//AopProxy创建是根据目标类是否有接口</span></span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">		<span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="AOP-代理-AopProxy"><a href="#AOP-代理-AopProxy" class="headerlink" title="AOP 代理 AopProxy"></a>AOP 代理 AopProxy</h3><p>AopProxy是Spring Aop提供的代理类，简单来说通过其实现类可以获取到代理类。</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727161056.png"></p>
<p>AopProxy接口提供的方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the AopProxy&#x27;s default class loader (if necessary for proxy creation):</span></span><br><span class="line"><span class="comment">	 * usually, the thread context class loader.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Thread#getContextClassLoader()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//获取一个代理对象</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> null&#125; will simply be passed down and thus lead to the low-level</span></span><br><span class="line"><span class="comment">	 * proxy facility&#x27;s default, which is usually different from the default chosen</span></span><br><span class="line"><span class="comment">	 * by the AopProxy implementation&#x27;s &#123;<span class="doctag">@link</span> #getProxy()&#125; method.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classLoader the class loader to create the proxy with</span></span><br><span class="line"><span class="comment">	 * (or &#123;<span class="doctag">@code</span> null&#125; for the low-level proxy facility&#x27;s default)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//根据类加载器获取代理对象</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AopProxy有两个实现类JdkDynamicAopProxy和CglibAopProxy，简单来说这两个代理类的功能就是生成目标代理类</p>
<h3 id="Advice-通知"><a href="#Advice-通知" class="headerlink" title="Advice 通知"></a>Advice 通知</h3><p>Advice通知，所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p>
<ol>
<li><p>BeforeAdvice、AfterAdvice：SpringAOP自定义的通知，用于拦截的方法之前或者之后，继承了AOP联盟的通知接口Advice。 </p>
</li>
<li><p>MethodBeforeAdvice、AfterReturningAdvice：仍然是SpringAOP自己的接口设计 </p>
<ul>
<li><p>MethodBeforeAdvice：继承了BeforeAdvice，但是BeforeAdvice只有这一个子类，即目前的SpringAOP只能实现对方法的拦截，不能实现对字段的拦截这种更精细的拦截，而Aspectj本身是支持这种拦截的。 </p>
<p>引入了接口方法： void before(Method method, Object[] args, Object target) throws Throwable;即在调用target的method方法之前我们可以做一些事情。 </p>
</li>
<li><p>AfterReturningAdvice：继承了AfterAdvice,引入了接口方法： void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable;必然比上面的</p>
<p>before方法多了一个返回值Object returnValue,使得我们可以对返回值进行操作和修改。 </p>
</li>
</ul>
</li>
<li><p>AspectJMethodBeforeAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice、AspectJAfterAdvice、AspectJAroundAdvice：上面的接口设计好了，就需要来实现它，这几个类都是借助于Aspectj来完成上述的功能。 </p>
<ul>
<li><p>前置通知：AspectJMethodBeforeAdvice</p>
</li>
<li><p>后置通知：AspectJAfterAdvice</p>
</li>
<li><p>异常通知：AspectJAfterThrowingAdvice</p>
</li>
<li><p>最终通知：AspectJAfterReturningAdvice</p>
</li>
<li><p>环绕通知：AspectJAroundAdvice</p>
</li>
</ul>
</li>
</ol>
<p>MethodInterceptor方法拦截器MethodInterceptor这一重要接口，所有的advice都要最终转化成MethodInterceptor，它的invoke接口方法包含了拦截器要执行的内容及执行的顺序。 </p>
<p>MethodInterceptor：是AOP联盟定义的接口，引入重要方法Object invoke(MethodInvocation invocation) throws Throwable；MethodInvocation invocation则像由一个个MethodInterceptor组成的链条（后面会进行说明），每次执行MethodInterceptor的invoke方法实现一个拦截，同时要把链条给它，以便继续执行下一个MethodInterceptor。 </p>
<p>对于advice构建成MethodInterceptor,分两种情况 </p>
<ol>
<li><p>advice本身就实现了MethodInterceptor，如AspectJAfterAdvice、AspectJAfterThrowingAdvice、AspectJAroundAdvice。 </p>
</li>
<li><p>那些没有实现MethodInterceptor的advice,如MethodBeforeAdvice、AfterReturningAdvice，则会进一步转换成MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor。这一过程又是采用适配器模式，适配器模式还是很常见的，所以要学会然后好好利用，如下面所示：</p>
</li>
</ol>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727162443.png"></p>
<p>AdvisorAdapter：Advisor适配器，用来创建MethodInterceptor。</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727162518.png"></p>
<p>AfterReturningAdviceAdapter用来生成AfterReturningAdviceInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">		AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AfterReturningAdviceInterceptor(advice);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>MethodBeforeAdviceAdapter用来生成MethodBeforeAdviceInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">		MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>ThrowsAdviceAdapter用来生成ThrowsAdviceInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ThrowsAdviceInterceptor(advisor.getAdvice());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>MethodInterceptor是如何实现拦截执行的</p>
</blockquote>
<p>每次执行MethodInterceptor的invoke方法实现一个拦截，同时要把链条给它，以便继续执行下一个MethodInterceptor。</p>
<ol>
<li>AspectJAfterAdvice：在mi.proceed()之后执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mi.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;<span class="comment">//最后执行</span></span><br><span class="line">			invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>AspectJAfterThrowingAdvice：在mi.proceed()之后执行异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mi.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">//出现异常后执行</span></span><br><span class="line">			<span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">				invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>MethodBeforeAdviceInterceptor：在mi.proceed()之前执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );<span class="comment">//执行之前运行</span></span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>AfterReturningAdviceInterceptor ：在mr.proceed执行获取返回值之后进行执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Object retVal = mi.proceed();<span class="comment">//执行之后运行</span></span><br><span class="line">		<span class="keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Advisor-切面"><a href="#Advisor-切面" class="headerlink" title="Advisor 切面"></a>Advisor 切面</h3><p>Advisor接口及其实现类是Advice(通知)和PointCut(切入点)的一个组合体，按照aop的定义其就是一个Aspect切面。</p>
<p>Advisor及其实现类：</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727163008.png"></p>
<p>在接口Advisor中定义了获取Advice通知的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取通知</span></span><br><span class="line">	<span class="function">Advice <span class="title">getAdvice</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在PointcutAdvisor中定义了获取PointCut的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PointcutAdvisor</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//获取切入点</span></span><br><span class="line">	<span class="function">Pointcut <span class="title">getPointcut</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说Advisor的实现类就是一个包含了Advice(通知)和PointCut(切入点)的数据结构。</p>
<p>我们来分析一下Spring配置文件中配置aop的配置属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;transaction&quot;</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;startTransaction&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *.save(..))&quot;</span>/&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;commitTransaction&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *.save(..))&quot;</span>/&gt;</span> </span><br><span class="line">	    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;rollbackTransaction&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *.save(..))&quot;</span>/&gt;</span> </span><br><span class="line">	    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;commitTransaction&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *.save(..))&quot;</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span> </span><br></pre></td></tr></table></figure>



<p>其中：</p>
<ol>
<li><p><code>&lt;aop:aspect&gt;</code>代表一个切面Advisor集合</p>
</li>
<li><p><code>ref=“transaction”</code> 代表了一个通知的集合，里面可能会有多个通知方法</p>
</li>
<li><p><code>pointcut</code> 代表切入点的匹配表达式</p>
</li>
<li><p>before、after等的method表示每个通知</p>
</li>
<li><p>before加上method加上pointcut就可以作为一个Advisor切面</p>
</li>
</ol>
<p>这样通过pointcut的匹配表达式，可以将Advice横切到目标类的方法中</p>
<h3 id="PointCut-切入点"><a href="#PointCut-切入点" class="headerlink" title="PointCut 切入点"></a>PointCut 切入点</h3><p>PointCut切入点简单来说就是用来指明Advice（增强）所作用的地方（一般指方法），PointCut简单来说是一个基于表达式的拦截条件。</p>
<p>PointCut接口及实现类：</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727163526.png"></p>
<p>PointCut接口提供了两个接口分别对类和方法进行匹配过滤，如果类及方法匹配成功则Advice就可以作用在方法上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the ClassFilter for this pointcut.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the ClassFilter (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//通过pointcut表达式对类进行过滤</span></span><br><span class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the MethodMatcher for this pointcut.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the MethodMatcher (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//通过pointcut表达式对方法进行过滤</span></span><br><span class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Canonical Pointcut instance that always matches.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//匹配所有的类及方法，默认返回true</span></span><br><span class="line">	Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在PointCut的子类AspectJExpressionPointcut中提供了两个方法对类和方法进行匹配判断，其最后的过滤的处理操作还是在aspectjweaver(aspectJ类库，AspectJ是一个专门用来实现动态代理(AOP编程)的类库，AspectJ是面向切面编程的框架，Spring使用就是这个类库实现动态代理的)这个jar中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对类进行过滤匹配</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		checkReadyToMatch();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.pointcutExpression.couldMatchJoinPointsInType(targetClass);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (ReflectionWorldException ex) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;PointcutExpression matching rejected target class - trying fallback expression&quot;</span>, ex);</span><br><span class="line">				PointcutExpression fallbackExpression = getFallbackPointcutExpression(targetClass);</span><br><span class="line">				<span class="keyword">if</span> (fallbackExpression != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> fallbackExpression.couldMatchJoinPointsInType(targetClass);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;PointcutExpression matching rejected target class&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//对方法进行过滤匹配</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> beanHasIntroductions)</span> </span>&#123;</span><br><span class="line">		checkReadyToMatch();</span><br><span class="line">		Method targetMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line">		ShadowMatch shadowMatch = getShadowMatch(targetMethod, method);</span><br><span class="line">		<span class="keyword">if</span> (shadowMatch.alwaysMatches()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (shadowMatch.neverMatches()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanHasIntroductions) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			RuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);</span><br><span class="line">			<span class="keyword">return</span> (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>总结：PointCut接口及其实现类就是根据我们配置的类及方法的过滤规则在调用Advice之前进行过滤，看看是否需要调用Advice。</p>
<h3 id="JoinPoint-连接点"><a href="#JoinPoint-连接点" class="headerlink" title="JoinPoint 连接点"></a>JoinPoint 连接点</h3><p>JoinPoint连接点：程序执行过程中明确的点，简单的来说就是Java程序执行过程中的方法。</p>
<p>JoinPoint接口图：</p>
<p><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200727163702.png"></p>
<p>JoinPoint通过抽象实现成为一个个的Method，在执行每个JoinPoint所代表的Method中，会执行对应的Advice。</p>
<p>JoinPoint接口提供的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Joinpoint</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//在实现中完成Method及Advice的执行</span></span><br><span class="line">	<span class="function">Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"> 	</span><br><span class="line">	<span class="function">Object <span class="title">getThis</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function">AccessibleObject <span class="title">getStaticPart</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在JoinPoint的实现类ReflectiveMethodInvocation中实现了方法proceed()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//interceptorsAndDynamicMethodMatchers所有同志的链表</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//如果所有的advice都已经进行处理就可以递归执行方法了</span></span><br><span class="line">			<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//每次获取一个advice</span></span><br><span class="line">		Object interceptorOrInterceptionAdvice =</span><br><span class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">			</span><br><span class="line">			InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">				<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> proceed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//在调用的Advice的invoke方法时会递归调用proceed方法</span></span><br><span class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>在interceptorsAndDynamicMethodMatchers中包含了需要切入某个方法所有的Advice通知，通过不断的递归调用完成所有的Advice和Method执行顺序的预处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//执行mi.proceed执行先执行BeforeAdvice</span></span><br><span class="line">		<span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>当链表中所有的Advice通知都被处理执行开始执行invokeJoinpoint方法，来进行对目标方法的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.publicMethod) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.methodProxy.invoke(<span class="keyword">this</span>.target, <span class="keyword">this</span>.arguments);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.invokeJoinpoint();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><ol>
<li><h4 id="基于注解：通过-AspectJ-execution-表达式拦截方法"><a href="#基于注解：通过-AspectJ-execution-表达式拦截方法" class="headerlink" title="基于注解：通过 AspectJ execution 表达式拦截方法"></a>基于注解：通过 AspectJ execution 表达式拦截方法</h4></li>
</ol>
<p>下面以一个最简单的例子，实现之前提到的环绕增强。先定义一个 Aspect 切面类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAspect</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Around(&quot;execution(* aop.demo.GreetingImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：类上面标注的 @Aspect 注解，这表明该类是一个 Aspect（其实就是 Advisor）。该类无需实现任何的接口，只需定义一个方法（方法叫什么名字都无所谓），只需在方法上标注 @Around 注解，在注解中使用了 AspectJ 切点表达式。方法的参数中包括一个 ProceedingJoinPoint 对象，它在 AOP 中称为 Joinpoint（连接点），可以通过该对象获取方法的任何信息，例如：方法名、参数等。</p>
<p>重点来分析一下这个切点表达式：</p>
<p>execution(* aop.demo.GreetingImpl.*(..))</p>
<ul>
<li>execution()：表示拦截方法，括号中可定义需要匹配的规则。</li>
<li>第一个“*”：表示方法的返回值是任意的。</li>
<li>第二个“*”：表示匹配该类中所有的方法。</li>
<li>(..)：表示方法的参数是任意的。</li>
</ul>
<ol start="2">
<li><h4 id="基于注解：通过-AspectJ-annotation-表达式拦截方法"><a href="#基于注解：通过-AspectJ-annotation-表达式拦截方法" class="headerlink" title="基于注解：通过 AspectJ @annotation 表达式拦截方法"></a>基于注解：通过 AspectJ @annotation 表达式拦截方法</h4></li>
</ol>
<p>为了拦截指定的注解的方法，我们首先需要来自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Tag &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上定义了一个 @Tag 注解，此注解可标注在方法上，在运行时生效。</p>
<p>只需将前面的 Aspect 类的切点表达式稍作改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAspect</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(aop.demo.Tag)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次使用了 @annotation() 表达式，只需在括号内定义需要拦截的注解名称即可。</p>
<p>直接将 @Tag 注解定义在您想要拦截的方法上，就这么简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingImpl</span> <span class="keyword">implements</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Tag</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello! &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上示例中只有一个方法，如果有多个方法，我们只想拦截其中某些时，这种解决方案会更加有价值。</p>
<p>除了 @Around 注解外，其实还有几个相关的注解，稍微归纳一下吧：</p>
<ul>
<li>@Before：前置增强</li>
<li>@After：后置增强</li>
<li>@Around：环绕增强</li>
<li>@AfterThrowing：抛出增强</li>
<li>@DeclareParents：引入增强</li>
</ul>
<p>此外还有一个 @AfterReturning（返回后增强），也可理解为 Finally 增强，相当于 finally 语句，它是在方法结束后执行的，也就说说，它比 @After 还要晚一些。</p>
<p>最后一个 @DeclareParents 竟然就是引入增强！为什么不叫做 @Introduction 呢？我也不知道为什么，但它干的活就是引入增强。</p>
<ol start="3">
<li><h4 id="引入增强"><a href="#引入增强" class="headerlink" title="引入增强"></a>引入增强</h4></li>
</ol>
<p>为了实现基于 AspectJ 的引入增强，我们同样需要定义一个 Aspect 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingAspect</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@DeclareParents(value = &quot;aop.demo.GreetingImpl&quot;, defaultImpl = ApologyImpl.class)</span></span><br><span class="line">    <span class="keyword">private</span> Apology apology;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>只需要在 Aspect 类中定义一个需要引入增强的接口，它也就是运行时需要动态实现的接口。在这个接口上标注了 @DeclareParents 注解，该注解有两个属性：</p>
<ul>
<li>value：目标类</li>
<li>defaultImpl：引入接口的默认实现类</li>
</ul>
<p>我们只需要对引入的接口提供一个默认实现类即可完成引入增强：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApologyImpl</span> <span class="keyword">implements</span> <span class="title">Apology</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySorry</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorry! &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Transaction-事务"><a href="#Spring-Transaction-事务" class="headerlink" title="Spring Transaction 事务"></a>Spring Transaction 事务</h2><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager。</p>
<h3 id="事务管理原理"><a href="#事务管理原理" class="headerlink" title="事务管理原理"></a>事务管理原理</h3><p>根据代理机制的不同，总结有五种事务配置方式</p>
<ul>
<li>每个 Bean 都有一个代理</li>
<li>所有 Bean 共享一个代理基类</li>
<li>使用拦截器</li>
<li>使用 tx 标签配置的拦截器</li>
<li>全注解</li>
</ul>
<h3 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h3><p>key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：  </p>
<ul>
<li>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h3 id="缓存管理原理"><a href="#缓存管理原理" class="headerlink" title="缓存管理原理"></a>缓存管理原理</h3><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="Spring-Event-和-Spring-Listener"><a href="#Spring-Event-和-Spring-Listener" class="headerlink" title="Spring Event 和 Spring Listener"></a>Spring Event 和 Spring Listener</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">NicZSAMA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gakkisama.com/2020/07/26/Spring%20Framework/">http://gakkisama.com/2020/07/26/Spring%20Framework/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gakkisama.com" target="_blank">o.0</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200726232916.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/27/%E8%BF%87%E6%BB%A4%E5%99%A8+%E7%9B%91%E5%90%AC%E5%99%A8+%E6%8B%A6%E6%88%AA%E5%99%A8+AOP%20%E6%AF%94%E8%BE%83/"><img class="prev-cover" src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200726232916.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring 监听器、过滤器、拦截器、AOP 比较</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/"><img class="next-cover" src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200723224703.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">红黑树</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210814135458.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">NicZSAMA</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Framework"><span class="toc-number">1.</span> <span class="toc-text">Spring Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">IOC 容器的初始化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E9%AB%98%E5%B1%82%E8%A7%86%E5%9B%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">容器的高层视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">初始化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IoC-%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">Spring IoC 容器核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext-%E5%92%8CApplicationContext-XML"><span class="toc-number">1.2.1.</span> <span class="toc-text">ApplicationContext 和ApplicationContext.XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryPostProcessor-%E5%92%8C-BeanPostProcessor"><span class="toc-number">1.2.2.</span> <span class="toc-text">BeanFactoryPostProcessor 和 BeanPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">BeanPostProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanPostProcessor%E4%BF%9D%E5%AD%98%E5%88%B0Spring%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">BeanPostProcessor保存到Spring容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%89%80%E6%9C%89%E7%9A%84BeanPostProcessor"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">执行所有的BeanPostProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactoryPostProcessor"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">BeanFactoryPostProcessor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory-%E5%92%8C-FactoryBean"><span class="toc-number">1.2.3.</span> <span class="toc-text">BeanFactory 和 FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FactoryBean"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">FactoryBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">BeanFactory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinition-%E5%92%8C-BeanDefinitionHolder"><span class="toc-number">1.2.4.</span> <span class="toc-text">BeanDefinition 和 BeanDefinitionHolder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanDefinition"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">BeanDefinition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanDefinitionHolder"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">BeanDefinitionHolder</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">Spring Bean 生命周期及循环引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">Bean 对象初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">Bean对象变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">Bean 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E5%AF%B9%E8%B1%A1%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.5.</span> <span class="toc-text">Bean 对象循环依赖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9Aprototype-%E5%8E%9F%E5%9E%8B-bean-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">第一种：prototype 原型 bean 循环依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9A%E5%8D%95%E4%BE%8Bbean-%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">第二种：单例bean 构造器参数循环依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%EF%BC%9A%E5%8D%95%E4%BE%8Bbean%E9%80%9A%E8%BF%87setXxx%E6%88%96%E8%80%85-Autowired%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">第三种：单例bean通过setXxx或者@Autowired进行循环依赖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">Spring AOP 面向切面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">cglib动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82-AopProxyFactory"><span class="toc-number">1.4.2.</span> <span class="toc-text">AOP 代理工厂 AopProxyFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-%E4%BB%A3%E7%90%86-AopProxy"><span class="toc-number">1.4.3.</span> <span class="toc-text">AOP 代理 AopProxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advice-%E9%80%9A%E7%9F%A5"><span class="toc-number">1.4.4.</span> <span class="toc-text">Advice 通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advisor-%E5%88%87%E9%9D%A2"><span class="toc-number">1.4.5.</span> <span class="toc-text">Advisor 切面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PointCut-%E5%88%87%E5%85%A5%E7%82%B9"><span class="toc-number">1.4.6.</span> <span class="toc-text">PointCut 切入点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JoinPoint-%E8%BF%9E%E6%8E%A5%E7%82%B9"><span class="toc-number">1.4.7.</span> <span class="toc-text">JoinPoint 连接点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AspectJ"><span class="toc-number">1.4.8.</span> <span class="toc-text">AspectJ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%EF%BC%9A%E9%80%9A%E8%BF%87-AspectJ-execution-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8B%A6%E6%88%AA%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">基于注解：通过 AspectJ execution 表达式拦截方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%EF%BC%9A%E9%80%9A%E8%BF%87-AspectJ-annotation-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8B%A6%E6%88%AA%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">基于注解：通过 AspectJ @annotation 表达式拦截方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">引入增强</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Transaction-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.</span> <span class="toc-text">Spring Transaction 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">事务管理原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">事务传播机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.4.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">缓存管理原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">1.6.</span> <span class="toc-text">Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">1.6.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Event-%E5%92%8C-Spring-Listener"><span class="toc-number">1.7.</span> <span class="toc-text">Spring Event 和 Spring Listener</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/21/Eureka/" title="无题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/08/21/Eureka/" title="无题">无题</a><time datetime="2021-08-21T01:13:11.430Z" title="发表于 2021-08-21 09:13:11">2021-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D/" title="互联网黑话手册"><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210814122555.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="互联网黑话手册"/></a><div class="content"><a class="title" href="/2021/04/30/%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D/" title="互联网黑话手册">互联网黑话手册</a><time datetime="2021-04-30T01:54:40.159Z" title="发表于 2021-04-30 09:54:40">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务及解决方案"><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210328211839.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式事务及解决方案"/></a><div class="content"><a class="title" href="/2021/03/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务及解决方案">分布式事务及解决方案</a><time datetime="2021-03-09T04:55:29.576Z" title="发表于 2021-03-09 12:55:29">2021-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/02/26/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法"><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210330122645.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="加密算法"/></a><div class="content"><a class="title" href="/2021/02/26/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法">加密算法</a><time datetime="2021-02-26T04:12:48.622Z" title="发表于 2021-02-26 12:12:48">2021-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/09/Jsoup%E5%A4%84%E7%90%86XSS%E6%94%BB%E5%87%BB/" title="Jsoup"><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200728142021.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Jsoup"/></a><div class="content"><a class="title" href="/2020/12/09/Jsoup%E5%A4%84%E7%90%86XSS%E6%94%BB%E5%87%BB/" title="Jsoup">Jsoup</a><time datetime="2020-12-09T04:57:11.708Z" title="发表于 2020-12-09 12:57:11">2020-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By NicZSAMA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'daebd464563e6ae79845',
      clientSecret: 'fd5d6562b84264b67f2c777b74bb97fa78f7a806',
      repo: 'gitalk',
      owner: 'niczsama',
      admin: ['niczsama'],
      id: 'f22b4a79cc1b9abb977179e0a28c2417',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
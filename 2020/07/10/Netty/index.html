<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>I/O 和 Netty | o.0</title><meta name="description" content="NettyI&#x2F;O 模型I&#x2F;O 模型基本说明I&#x2F;O 模型简单理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能 Java 共支持三种网络编程模型 I&#x2F;O 模式：BIO、NIO、AIO BIO BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善"><meta name="author" content="NicZSAMA"><meta name="copyright" content="NicZSAMA"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gakkisama.com/2020/07/10/Netty/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="I/O 和 Netty"><meta property="og:url" content="http://gakkisama.com/2020/07/10/Netty/"><meta property="og:site_name" content="o.0"><meta property="og:description" content="NettyI&#x2F;O 模型I&#x2F;O 模型基本说明I&#x2F;O 模型简单理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能 Java 共支持三种网络编程模型 I&#x2F;O 模式：BIO、NIO、AIO BIO BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善"><meta property="og:image" content="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710110543.png"><meta property="article:published_time" content="2020-07-10T03:03:01.164Z"><meta property="article:modified_time" content="2020-09-04T06:45:18.608Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="红黑树" href="http://gakkisama.com/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/"><link rel="next" title="Dubbo" href="http://gakkisama.com/2020/07/05/Dubbo/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"languages":{"author":"作者: NicZSAMA","link":"链接: ","source":"来源: o.0","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200724150506.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty"><span class="toc-number">1.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-模型"><span class="toc-number">1.1.</span> <span class="toc-text">I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-模型基本说明"><span class="toc-number">1.1.1.</span> <span class="toc-text">I&#x2F;O 模型基本说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">AIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#零拷贝"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">零拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO-的三核心组件"><span class="toc-number">1.2.</span> <span class="toc-text">NIO 的三核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通道（Channels）"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">通道（Channels）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区-（Buffers）"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">缓冲区 （Buffers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择器（Selectors）"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">选择器（Selectors）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channels"><span class="toc-number">1.2.1.</span> <span class="toc-text">Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-和-Stream-对比"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">channel 和 Stream 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel的实现（Channel-Implementations）"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Channel的实现（Channel Implementations）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel的基础示例（Basic-Channel-Example）"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">Channel的基础示例（Basic Channel Example）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel文件通道"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">FileChannel文件通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel-to-Channel-Transfers通道传输接口"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">Channel to Channel Transfers通道传输接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocketChannel-服务端套接字通道"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">ServerSocketChannel 服务端套接字通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel套接字通道"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">SocketChannel套接字通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffers"><span class="toc-number">1.2.2.</span> <span class="toc-text">Buffers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-基本用法"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Buffer 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer的容量，位置，上限（Buffer-Capacity-Position-and-Limit）"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#容量（Capacity）"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">容量（Capacity）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#位置（Position）"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">位置（Position）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#上限（Limit）"><span class="toc-number">1.2.2.2.3.</span> <span class="toc-text">上限（Limit）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-类型"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Buffer 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-操作"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">Buffer 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#分配一个Buffer（Allocating-a-Buffer）"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">分配一个Buffer（Allocating a Buffer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#写入数据到Buffer（Writing-Data-to-a-Buffer）"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">写入数据到Buffer（Writing Data to a Buffer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#翻转（flip-）"><span class="toc-number">1.2.2.4.3.</span> <span class="toc-text">翻转（flip()）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#从Buffer读取数据（Reading-Data-from-a-Buffer）"><span class="toc-number">1.2.2.4.4.</span> <span class="toc-text">从Buffer读取数据（Reading Data from a Buffer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rewind"><span class="toc-number">1.2.2.4.5.</span> <span class="toc-text">rewind()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#clear-and-compact"><span class="toc-number">1.2.2.4.6.</span> <span class="toc-text">clear() and compact()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mark-and-reset"><span class="toc-number">1.2.2.4.7.</span> <span class="toc-text">mark() and reset()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#equals-and-compareTo"><span class="toc-number">1.2.2.4.8.</span> <span class="toc-text">equals() and compareTo()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#equals"><span class="toc-number">1.2.2.4.9.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#compareTo"><span class="toc-number">1.2.2.4.10.</span> <span class="toc-text">compareTo()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO-Scatter-Gather"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">Java NIO Scatter &#x2F; Gather</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selectors"><span class="toc-number">1.2.3.</span> <span class="toc-text">Selectors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用Selector（Why-Use-a-Selector-）"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">为什么使用Selector（Why Use a Selector?）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何使用selector（How-Use-a-Selector）"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">如何使用selector（How Use a Selector）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从Selector中选择channel-Selecting-Channels-via-a-Selector"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">从Selector中选择channel(Selecting Channels via a Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#举个栗子-Full-Selector-Example"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">举个栗子(Full Selector Example)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector、poll、epoll"><span class="toc-number">1.2.4.</span> <span class="toc-text">selector、poll、epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">epoll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty终于来啦！！！"><span class="toc-number">1.3.</span> <span class="toc-text">Netty终于来啦！！！</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty介绍"><span class="toc-number">1.3.1.</span> <span class="toc-text">Netty介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactor-I-O-模型"><span class="toc-number">1.3.2.</span> <span class="toc-text">Reactor I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#经典Reactor模式（单线程模式）"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">经典Reactor模式（单线程模式）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多工作线程Reactor模式"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">多工作线程Reactor模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多Reactor"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">多Reactor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty模型"><span class="toc-number">1.3.3.</span> <span class="toc-text">Netty模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty模型的简单实现"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Netty模型的简单实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty异步模型"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Netty异步模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-实现-HTTP-服务"><span class="toc-number">1.3.4.</span> <span class="toc-text">Netty 实现 HTTP 服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-核心组件"><span class="toc-number">1.3.5.</span> <span class="toc-text">Netty 核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bootstrap-和-ServerBootstrap"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">Bootstrap 和 ServerBootstrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventLoopGroup-和其实现类-NioEventLoopGroup"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">EventLoopGroup 和其实现类 NioEventLoopGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector-1"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#任务队列TaskQueue"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">任务队列TaskQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future、ChannelFuture"><span class="toc-number">1.3.5.6.</span> <span class="toc-text">Future、ChannelFuture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelHandler-及其实现类"><span class="toc-number">1.3.5.7.</span> <span class="toc-text">ChannelHandler 及其实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelHandlerContext"><span class="toc-number">1.3.5.8.</span> <span class="toc-text">ChannelHandlerContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline-和-ChannelPipeline"><span class="toc-number">1.3.5.9.</span> <span class="toc-text">Pipeline 和 ChannelPipeline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelOption"><span class="toc-number">1.3.5.10.</span> <span class="toc-text">ChannelOption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteBuf分类及其使用"><span class="toc-number">1.3.5.11.</span> <span class="toc-text">ByteBuf分类及其使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unpooled-类"><span class="toc-number">1.3.5.12.</span> <span class="toc-text">Unpooled 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty-群聊系统简单实现"><span class="toc-number">1.3.5.13.</span> <span class="toc-text">Netty 群聊系统简单实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty心跳检测机制栗子"><span class="toc-number">1.3.5.14.</span> <span class="toc-text">Netty心跳检测机制栗子</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710110543.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">o.0</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">I/O 和 Netty</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-10 11:03:01"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-04 14:45:18"><i class="fas fa-history fa-fw"></i> 更新于 2020-09-04</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><h3 id="I-O-模型基本说明"><a href="#I-O-模型基本说明" class="headerlink" title="I/O 模型基本说明"></a>I/O 模型基本说明</h3><p>I/O 模型简单理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p>
<p>Java 共支持三种网络编程模型 I/O 模式：BIO、NIO、AIO</p>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><ul>
<li>BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710093117.png" alt="java BIO(阻塞IO，即传统IO)分析- Mica_Dai - 博客园"></p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><ul>
<li><p>NIO：非阻塞IO</p>
<ul>
<li>同步非阻塞，服务器实现模式为多个连接一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。</li>
<li>异步阻塞， 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710102852.jpg" alt="JAVA NIO 之Selector 组件"></p>
</li>
</ul>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><ul>
<li>AIO：异步非阻塞IO，在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。</li>
</ul>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>​        Java NIO中提供的FileChannel拥有transferTo和transferFrom两个方法，可直接把FileChannel中的数据拷贝到另外一个Channel，或者直接把另外一个Channel中的数据拷贝到FileChannel。该接口常被用于高效的网络/文件的数据传输和大文件拷贝。在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于Java IO中提供的方法。</p>
<p>使用FileChannel的零拷贝将本地文件内容传输到网络的示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">    InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>);</span><br><span class="line">    socketChannel.connect(address);</span><br><span class="line"></span><br><span class="line">    RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(</span><br><span class="line">        NIOClient.class.getClassLoader().getResource("test.txt").getFile(), "rw");</span><br><span class="line">    FileChannel channel = file.getChannel();</span><br><span class="line">    channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line">    channel.close();</span><br><span class="line">    file.close();</span><br><span class="line">    socketChannel.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>linux系统的五种网络模型方案</p>
</blockquote>
<ul>
<li>阻塞 I/O（blocking IO）  一直等待</li>
<li>非阻塞 I/O（nonblocking IO）询问等待</li>
<li>I/O 多路复用（ IO multiplexing）有人专门询问等待</li>
<li>信号驱动 I/O（ signal driven IO）异步通知自己去拿（内核到用户）</li>
<li>异步 I/O（asynchronous IO） 异步有人帮你送来（内核到用户）</li>
</ul>
<h2 id="NIO-的三核心组件"><a href="#NIO-的三核心组件" class="headerlink" title="NIO 的三核心组件"></a>NIO 的三核心组件</h2><p>整个NIO体系包含的类远远不止这几个，但是在笔者看来Channel,Buffer和Selector组成了这个核心的API。其他的一些组件，比如Pipe和FileLock仅仅只作为上述三个的负责类。因此在概览这一节中，会重点关注这三个概念。其他的组件会在各自的部分单独介绍。</p>
<h4 id="通道（Channels）"><a href="#通道（Channels）" class="headerlink" title="通道（Channels）"></a>通道（Channels）</h4><p>通常来说NIO中的所有IO都是从Channel开始的。Channel和流有点类似。通过Channel，我们即可以从Channel把数据写到Buffer中，也可以把数据冲Buffer写入到Channel，下图是一个示意图：</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710131127.png" alt="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png"></p>
<p><strong>Java NIO: Channels read data into Buffers, and Buffers write data into Channels</strong></p>
<p>有很多的Channel，Buffer类型。下面列举了主要的几种：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>这些channel基于于UDP和TCP的网络IO，以及文件IO。</p>
<h4 id="缓冲区-（Buffers）"><a href="#缓冲区-（Buffers）" class="headerlink" title="缓冲区 （Buffers）"></a>缓冲区 （Buffers）</h4><p> 下面是核心的Buffer实现类的列表：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer涵盖了可以通过IO操作的基础类型：byte,short,int,long,float,double以及characters. NIO实际上还包含一种MappedBytesBuffer,一般用于和内存映射的文件。</p>
<h4 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h4><p>选择器允许单线程操作多个通道。如果你的程序中有大量的链接，同时每个链接的IO带宽不高的话，这个特性将会非常有帮助。比如聊天服务器。 下面是一个单线程中Slector维护3个Channel的示意图：</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200901170224.png" alt=""></p>
<p><strong>Java NIO: A Thread uses a Selector to handle 3 Channel’s</strong></p>
<p>要使用Selector的话，我们必须把Channel注册到Selector上，然后就可以调用Selector的select()方法。这个方法会进入阻塞，直到有一个channel的状态符合条件。当方法返回后，线程可以处理这些事件。</p>
<h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><h4 id="channel-和-Stream-对比"><a href="#channel-和-Stream-对比" class="headerlink" title="channel 和 Stream 对比"></a>channel 和 Stream 对比</h4><p>Java NIO Channel通道和流非常相似，主要有以下几点区别：</p>
<ul>
<li>通道可以读也可以写，流一般来说是单向的（只能读或者写）。</li>
<li>通道可以异步读写。</li>
<li>通道总是基于缓冲区Buffer来读写。</li>
</ul>
<p>正如上面提到的，我们可以从通道中读取数据，写入到buffer；也可以中buffer内读数据，写入到通道中。</p>
<h4 id="Channel的实现（Channel-Implementations）"><a href="#Channel的实现（Channel-Implementations）" class="headerlink" title="Channel的实现（Channel Implementations）"></a>Channel的实现（Channel Implementations）</h4><p>下面列出Java NIO中最重要的集中Channel的实现：</p>
<ul>
<li>FileChannel                    用于文件的数据读写</li>
<li>DatagramChannel        用于UDP的数据读写</li>
<li>SocketChannel              用于TCP的数据读写</li>
<li>ServerSocketChannel   允许我们监听TCP链接请求，每个请求会创建一个SocketChannel.</li>
</ul>
<h4 id="Channel的基础示例（Basic-Channel-Example）"><a href="#Channel的基础示例（Basic-Channel-Example）" class="headerlink" title="Channel的基础示例（Basic Channel Example）"></a>Channel的基础示例（Basic Channel Example）</h4><p>这有一个利用FileChannel读取数据到Buffer的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">  buf.flip();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear();</span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>

<p>注意buf.flip()的调用。首先把数据读取到Buffer中，然后调用flip()方法。接着再把数据读取出来。</p>
<h4 id="FileChannel文件通道"><a href="#FileChannel文件通道" class="headerlink" title="FileChannel文件通道"></a>FileChannel文件通道</h4><p>Java NIO中的FileChannel是用于连接文件的通道。通过文件通道可以读、写文件的数据。Java NIO的FileChannel是相对标准Java IO API的可选接口。</p>
<p>FileChannel不可以设置为非阻塞模式，他只能在阻塞模式下运行。</p>
<blockquote>
<p>打开文件通道（Opening a FileChannel）</p>
</blockquote>
<p>在使用FileChannel前必须打开通道，打开一个文件通道需要通过输入/输出流或者RandomAccessFile，下面是通过RandomAccessFile打开文件通道的案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile &#x3D; new RandomAccessFile(&quot;data&#x2F;nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel &#x3D; aFile.getChannel();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从文件通道内读取数据（Reading Data from a FileChannel）</p>
</blockquote>
<p>读取文件通道的数据可以通过read方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead &#x3D; inChannel.read(buf);</span><br></pre></td></tr></table></figure>

<p>首先开辟一个Buffer，从通道中读取的数据会写入Buffer内。接着就可以调用read方法，read的返回值代表有多少字节被写入了Buffer，返回-1则表示已经读取到文件结尾了。</p>
<blockquote>
<p>向文件通道写入数据（Writing Data to a FileChannel）</p>
</blockquote>
<p>写数据用write方法，入参是Buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData &#x3D; &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的write调用写在了wihle循环中，这是因为write不能保证有多少数据真实被写入，因此需要循环写入直到没有更多数据。</p>
<blockquote>
<p>关闭通道（Closing a FileChannel）</p>
</blockquote>
<p>操作完毕后，需要把通道关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileChannel Position</p>
</blockquote>
<p>当操作FileChannel的时候读和写都是基于特定起始位置的（position），获取当前的位置可以用FileChannel的position()方法，设置当前位置可以用带参数的position(long pos)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long pos channel.position();</span><br><span class="line"></span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure>

<p>假设我们把当前位置设置为文件结尾之后，那么当我们视图从通道中读取数据时就会发现返回值是-1，表示已经到达文件结尾了。 如果把当前位置设置为文件结尾之后，在想通道中写入数据，文件会自动扩展以便写入数据，但是这样会导致文件中出现类似空洞，即文件的一些位置是没有数据的。</p>
<blockquote>
<p>FileChannel Size</p>
</blockquote>
<p>size()方法可以返回FileChannel对应的文件的文件大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long fileSize &#x3D; channel.size();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileChannel Truncate</p>
</blockquote>
<p>利用truncate方法可以截取指定长度的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileChannel Force</p>
</blockquote>
<p>force方法会把所有未写磁盘的数据都强制写入磁盘。这是因为在操作系统中出于性能考虑回把数据放入缓冲区，所以不能保证数据在调用write写入文件通道后就及时写到磁盘上了，除非手动调用force方法。 force方法需要一个布尔参数，代表是否把meta data也一并强制写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure>



<h4 id="Channel-to-Channel-Transfers通道传输接口"><a href="#Channel-to-Channel-Transfers通道传输接口" class="headerlink" title="Channel to Channel Transfers通道传输接口"></a>Channel to Channel Transfers通道传输接口</h4><p>在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。逐个特性得益于FileChannel包含的transferTo和transferFrom两个方法。</p>
<blockquote>
<p>transferFrom()</p>
</blockquote>
<p>FileChannel.transferFrom方法把数据从通道源传输到FileChannel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile &#x3D; new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      fromChannel &#x3D; fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile &#x3D; new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      toChannel &#x3D; toFile.getChannel();</span><br><span class="line"></span><br><span class="line">long position &#x3D; 0;</span><br><span class="line">long count    &#x3D; fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure>

<p>transferFrom的参数position和count表示目标文件的写入位置和最多写入的数据量。如果通道源的数据小于count那么就传实际有的数据量。 另外，有些SocketChannel的实现在传输时只会传输哪些处于就绪状态的数据，即使SocketChannel后续会有更多可用数据。因此，这个传输过程可能不会传输整个的数据。</p>
<blockquote>
<p>transferTo()</p>
</blockquote>
<p>transferTo方法把FileChannel数据传输到另一个channel,下面是案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile &#x3D; new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      fromChannel &#x3D; fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile &#x3D; new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel      toChannel &#x3D; toFile.getChannel();</span><br><span class="line"></span><br><span class="line">long position &#x3D; 0;</span><br><span class="line">long count    &#x3D; fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>

<p>这段代码和之前介绍transfer时的代码非常相似，区别只在于调用方法的是哪个FileChannel.</p>
<p>SocketChannel的问题也存在与transferTo.SocketChannel的实现可能只在发送的buffer填充满后才发送，并结束。</p>
<h4 id="ServerSocketChannel-服务端套接字通道"><a href="#ServerSocketChannel-服务端套接字通道" class="headerlink" title="ServerSocketChannel 服务端套接字通道"></a>ServerSocketChannel 服务端套接字通道</h4><p>在Java NIO中，ServerSocketChannel是用于监听TCP链接请求的通道，正如Java网络编程中的ServerSocket一样。</p>
<p>ServerSocketChannel实现类位于java.nio.channels包下面。 下面是一个示例程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9999));</span><br><span class="line">while(true) &#123;</span><br><span class="line">  SocketChannel socketChannel &#x3D; serverSocketChannel.accept();</span><br><span class="line">  &#x2F;&#x2F;do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打开ServerSocketChannel</p>
</blockquote>
<p>打开一个ServerSocketChannel我们需要调用他的open()方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关闭ServerSocketChannel</p>
</blockquote>
<p>关闭一个ServerSocketChannel我们需要调用他的close()方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>监听链接</p>
</blockquote>
<p>通过调用accept()方法，我们就开始监听端口上的请求连接。当accept()返回时，他会返回一个SocketChannel连接实例，实际上accept()是阻塞操作，他会阻塞当前去线程直到返回一个连接； 很多时候我们是不满足于监听一个连接的，因此我们会把accept()的调用放到循环中，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel &#x3D; serverSocketChannel.accept();</span><br><span class="line">    &#x2F;&#x2F;do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们可以在循环体内加上合适的中断逻辑，而不是单纯的在while循环中写true，以此来结束循环监听；</p>
<blockquote>
<p>非阻塞模式</p>
</blockquote>
<p>实际上ServerSocketChannel是可以设置为非阻塞模式的。在非阻塞模式下，调用accept()函数会立刻返回，如果当前没有请求的链接，那么返回值为空null。因此我们需要手动检查返回的SocketChannel是否为空，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9999));</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel &#x3D; serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    if(socketChannel !&#x3D; null)&#123;</span><br><span class="line">        &#x2F;&#x2F;do something with socketChannel...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SocketChannel套接字通道"><a href="#SocketChannel套接字通道" class="headerlink" title="SocketChannel套接字通道"></a>SocketChannel套接字通道</h4><p>在Java NIO体系中，SocketChannel是用于TCP网络连接的套接字接口，相当于Java网络编程中的Socket套接字接口。创建SocketChannel主要有两种方式，如下：</p>
<ol>
<li>打开一个SocketChannel并连接网络上的一台服务器。</li>
<li>当ServerSocketChannel接收到一个连接请求时，会创建一个SocketChannel。</li>
</ol>
<blockquote>
<p>建立一个SocketChannel连接</p>
</blockquote>
<p>打开一个SocketChannel可以这样操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://gakkisama.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关闭一个SocketChannel连接</p>
</blockquote>
<p>关闭一个SocketChannel只需要调用他的close方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从SocketChannel中读数据</p>
</blockquote>
<p>从一个SocketChannel连接中读取数据，可以通过read()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure>

<p>首先需要开辟一个Buffer。从SocketChannel中读取的数据将放到Buffer中。</p>
<p>接下来就是调用SocketChannel的read()方法.这个read()会把通道中的数据读到Buffer中。read()方法的返回值是一个int数据，代表此次有多少字节的数据被写入了Buffer中。如果返回的是-1,那么意味着通道内的数据已经读取完毕，到底了（链接关闭）。</p>
<blockquote>
<p>向SocketChannel写数据</p>
</blockquote>
<p>向SocketChannel中写入数据是通过write()方法，write也需要一个Buffer作为参数。下面看一下具体的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细观察代码，这里我们把write()的调用放在了while循环中。这是因为我们无法保证在write的时候实际写入了多少字节的数据，因此我们通过一个循环操作，不断把Buffer中数据写入到SocketChannel中知道Buffer中的数据全部写入为止。</p>
<blockquote>
<p>非阻塞模式</p>
</blockquote>
<p>我们可以把SocketChannel设置为non-blocking（非阻塞）模式。这样的话在调用connect(), read(), write()时都是异步的。</p>
<blockquote>
<p>connect()</p>
</blockquote>
<p>如果我们设置了一个SocketChannel是非阻塞的，那么调用connect()后，方法会在链接建立前就直接返回。为了检查当前链接是否建立成功，我们可以调用finishConnect(),如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://gakkisama.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    <span class="comment">//wait, or do something else...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>write()</p>
</blockquote>
<p>在非阻塞模式下，调用write()方法不能确保方法返回后写入操作一定得到了执行。因此我们需要把write()调用放到循环内。这和前面在讲write()时是一样的，此处就不在代码演示。</p>
<blockquote>
<p>read()</p>
</blockquote>
<p>在非阻塞模式下，调用read()方法也不能确保方法返回后，确实读到了数据。因此我们需要自己检查的整型返回值，这个返回值会告诉我们实际读取了多少字节的数据。</p>
<blockquote>
<p>Selector结合非阻塞模式</p>
</blockquote>
<p>SocketChannel的非阻塞模式可以和Selector很好的协同工作。把一个或多个SocketChannel注册到一个Selector后，我们可以通过Selector指导哪些channels通道是处于可读，可写等等状态的。后续我们会再详细阐述如果联合使用Selector与SocketChannel。</p>
<h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><h4 id="Buffer-基本用法"><a href="#Buffer-基本用法" class="headerlink" title="Buffer 基本用法"></a>Buffer 基本用法</h4><p>利用Buffer读写数据，通常遵循四个步骤：</p>
<ul>
<li>把数据写入buffer；</li>
<li>调用flip；</li>
<li>从Buffer中读取数据；</li>
<li>调用buffer.clear()或者buffer.compact()</li>
</ul>
<p>当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer有两种方式：调用clear()或compact()方法。clear会清空整个buffer，compact则只清空已读取的数据，未被读取的数据会被移动到buffer的开始位置，写入位置则近跟着未读数据之后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  buf.flip();  <span class="comment">//make buffer ready for read</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// read 1 byte at a time</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear(); <span class="comment">//make buffer ready for writing</span></span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>

<h4 id="Buffer的容量，位置，上限（Buffer-Capacity-Position-and-Limit）"><a href="#Buffer的容量，位置，上限（Buffer-Capacity-Position-and-Limit）" class="headerlink" title="Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）"></a>Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）</h4><p>buffer缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被NIO Buffer管理，并提供一系列的方法用于更简单的操作这块内存。</p>
<p>一个Buffer有三个属性是必须掌握的，分别是：</p>
<ul>
<li>capacity容量</li>
<li>position位置</li>
<li>limit限制</li>
</ul>
<p>position和limit的具体含义取决于当前buffer的模式。capacity在两种模式下都表示容量。</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710130001.png" alt="buffers-modes.png"></p>
<p><strong>Buffer capacity, position and limit in write and read mode.</strong></p>
<blockquote>
<h5 id="容量（Capacity）"><a href="#容量（Capacity）" class="headerlink" title="容量（Capacity）"></a>容量（Capacity）</h5></blockquote>
<p>作为一块内存，buffer有一个固定的大小，叫做capacity容量。也就是最多只能写入容量值的字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据。</p>
<blockquote>
<h5 id="位置（Position）"><a href="#位置（Position）" class="headerlink" title="位置（Position）"></a>位置（Position）</h5></blockquote>
<p>当写入数据到Buffer的时候需要中一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1.</p>
<p>当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。</p>
<blockquote>
<h5 id="上限（Limit）"><a href="#上限（Limit）" class="headerlink" title="上限（Limit）"></a>上限（Limit）</h5></blockquote>
<p>在写模式，limit的含义是我们所能写入的最大数据量。它等同于buffer的容量。</p>
<p>一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。</p>
<p>数据读取的上限时buffer中已有的数据，也就是limit的位置（原position所指的位置）。</p>
<h4 id="Buffer-类型"><a href="#Buffer-类型" class="headerlink" title="Buffer 类型"></a>Buffer 类型</h4><blockquote>
<p>Buffer Types</p>
</blockquote>
<p>Java NIO有如下具体的Buffer类型：</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>Buffer的类型代表了不同数据类型，换句话说，Buffer中的数据可以是上述的基本类型；</p>
<h4 id="Buffer-操作"><a href="#Buffer-操作" class="headerlink" title="Buffer 操作"></a>Buffer 操作</h4><blockquote>
<h5 id="分配一个Buffer（Allocating-a-Buffer）"><a href="#分配一个Buffer（Allocating-a-Buffer）" class="headerlink" title="分配一个Buffer（Allocating a Buffer）"></a>分配一个Buffer（Allocating a Buffer）</h5></blockquote>
<p>为了获取一个Buffer对象，你必须先分配。每个Buffer实现类都有一个allocate()方法用于分配内存。下面看一个实例,开辟一个48字节大小的buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</span><br></pre></td></tr></table></figure>

<p>开辟一个1024个字符的CharBuffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf &#x3D; CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>

<blockquote>
<h5 id="写入数据到Buffer（Writing-Data-to-a-Buffer）"><a href="#写入数据到Buffer（Writing-Data-to-a-Buffer）" class="headerlink" title="写入数据到Buffer（Writing Data to a Buffer）"></a>写入数据到Buffer（Writing Data to a Buffer）</h5></blockquote>
<p>写数据到Buffer有两种方法：</p>
<ul>
<li>从Channel中写数据到Buffer</li>
<li>手动写数据到Buffer，调用put方法</li>
</ul>
<p>下面是一个实例，演示从Channel写数据到Buffer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead &#x3D; inChannel.read(buf); &#x2F;&#x2F;read into buffer.</span><br></pre></td></tr></table></figure>

<p>通过put写数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure>

<p>put方法有很多不同版本，对应不同的写数据方法。例如把数据写到特定的位置，或者把一个字节数据写入buffer。看考JavaDoc文档可以查阅到更多数据。</p>
<blockquote>
<h5 id="翻转（flip-）"><a href="#翻转（flip-）" class="headerlink" title="翻转（flip()）"></a>翻转（flip()）</h5></blockquote>
<p>flip()方法可以吧Buffer从写模式切换到读模式。调用flip方法会把position归零，并设置limit为之前的position的值。 也就是说，现在position代表的是读取位置，limit标示的是已写入的数据位置。</p>
<blockquote>
<h5 id="从Buffer读取数据（Reading-Data-from-a-Buffer）"><a href="#从Buffer读取数据（Reading-Data-from-a-Buffer）" class="headerlink" title="从Buffer读取数据（Reading Data from a Buffer）"></a>从Buffer读取数据（Reading Data from a Buffer）</h5></blockquote>
<p>从Buffer读数据也有两种方式。</p>
<ul>
<li>从buffer读数据到channel</li>
<li>从buffer直接读取数据，调用get方法</li>
</ul>
<p>读取数据到channel的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;read from buffer into channel.</span><br><span class="line">int bytesWritten &#x3D; inChannel.write(buf);</span><br></pre></td></tr></table></figure>

<p>调用get读取数据的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte aByte &#x3D; buf.get();</span><br></pre></td></tr></table></figure>

<p>get也有诸多版本，对应了不同的读取方式。</p>
<blockquote>
<h5 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h5></blockquote>
<p>Buffer.rewind()方法将position置为0，这样我们可以重复读取buffer中的数据。limit保持不变。</p>
<blockquote>
<h5 id="clear-and-compact"><a href="#clear-and-compact" class="headerlink" title="clear() and compact()"></a>clear() and compact()</h5></blockquote>
<p>一旦我们从buffer中读取完数据，需要复用buffer为下次写数据做准备。只需要调用clear或compact方法。</p>
<p>clear方法会重置position为0，limit为capacity，也就是整个Buffer清空。实际上Buffer中数据并没有清空，我们只是把标记为修改了。</p>
<p>如果Buffer还有一些数据没有读取完，调用clear就会导致这部分数据被“遗忘”，因为我们没有标记这部分数据未读。</p>
<p>针对这种情况，如果需要保留未读数据，那么可以使用compact。 因此compact和clear的区别就在于对未读数据的处理，是保留这部分数据还是一起清空。</p>
<blockquote>
<h5 id="mark-and-reset"><a href="#mark-and-reset" class="headerlink" title="mark() and reset()"></a>mark() and reset()</h5></blockquote>
<p>通过mark方法可以标记当前的position，通过reset来恢复mark的位置，这个非常像canva的save和restore：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;call buffer.get() a couple of times, e.g. during parsing.</span><br><span class="line"></span><br><span class="line">buffer.reset();  &#x2F;&#x2F;set position back to mark.</span><br></pre></td></tr></table></figure>

<blockquote>
<h5 id="equals-and-compareTo"><a href="#equals-and-compareTo" class="headerlink" title="equals() and compareTo()"></a>equals() and compareTo()</h5></blockquote>
<p>可以用eqauls和compareTo比较两个buffer</p>
<ul>
<li><h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><p>判断两个buffer相等 ，需满足：</p>
<ul>
<li>类型相同</li>
<li>buffer中剩余字节数相同</li>
<li>所有剩余字节相等</li>
</ul>
</li>
</ul>
<p>从上面的三个条件可以看出，equals只比较buffer中的部分内容，并不会去比较每一个元素。</p>
<ul>
<li><h5 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h5></li>
</ul>
<p>compareTo也是比较buffer中的剩余元素，只不过这个方法适用于比较排序的。</p>
<h4 id="Java-NIO-Scatter-Gather"><a href="#Java-NIO-Scatter-Gather" class="headerlink" title="Java NIO Scatter / Gather"></a>Java NIO Scatter / Gather</h4><p>Java NIO发布时内置了对scatter / gather的支持。scatter / gather是通过通道读写数据的两个概念。</p>
<p>Scattering read指的是从通道读取的操作能把数据写入多个buffer，也就是sctters代表了数据从一个channel到多个buffer的过程。</p>
<p>gathering write则正好相反，表示的是从多个buffer把数据写入到一个channel中。</p>
<p>Scatter/gather在有些场景下会非常有用，比如需要处理多份分开传输的数据。举例来说，假设一个消息包含了header和body，我们可能会把header和body保存在不同独立buffer中，这种分开处理header与body的做法会使开发更简明。</p>
<blockquote>
<p>Scattering Reads</p>
</blockquote>
<p>“scattering read”是把数据从单个Channel写入到多个buffer，下面是示意图：</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710152307.png" alt="scatter.png"></p>
<ul>
<li><strong>Java NIO: Scattering Read</strong></li>
</ul>
<p>用代码来表示的话如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>

<p>观察代码可以发现，我们把多个buffer写在了一个数组中，然后把数组传递给channel.read()方法。read()方法内部会负责把数据按顺序写进传入的buffer数组内。一个buffer写满后，接着写到下一个buffer中。</p>
<p>实际上，scattering read内部必须写满一个buffer后才会向后移动到下一个buffer，因此这并不适合消息大小会动态改变的部分，也就是说，如果你有一个header和body，并且header有一个固定的大小（比如128字节）,这种情形下可以正常工作。</p>
<blockquote>
<p>Gathering Writes</p>
</blockquote>
<p>“gathering write”把多个buffer的数据写入到同一个channel中，下面是示意图：</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710152307.png" alt="gather.png"></p>
<ul>
<li><strong>Java NIO: Gathering Write</strong></li>
</ul>
<p>用代码表示的话如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header &#x3D; ByteBuffer.allocate(128);</span><br><span class="line">ByteBuffer body   &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;write data into buffers</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray &#x3D; &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>

<p>类似的传入一个buffer数组给write，内部机会按顺序将数组内的内容写进channel，这里需要注意，写入的时候针对的是buffer中position到limit之间的数据。也就是如果buffer的容量是128字节，但它只包含了58字节数据，那么写入的时候只有58字节会真正写入。因此gathering write是可以适用于可变大小的message的，这和scattering reads不同。</p>
<h3 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h3><p>Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。</p>
<h4 id="为什么使用Selector（Why-Use-a-Selector-）"><a href="#为什么使用Selector（Why-Use-a-Selector-）" class="headerlink" title="为什么使用Selector（Why Use a Selector?）"></a>为什么使用Selector（Why Use a Selector?）</h4><p>用单线程处理多个channels的好处是我需要更少的线程来处理channel。实际上，你甚至可以用一个线程来处理所有的channels。从操作系统的角度来看，切换线程开销是比较昂贵的，并且每个线程都需要占用系统资源，因此暂用线程越少越好。</p>
<p>需要留意的是，现代操作系统和CPU在多任务处理上已经变得越来越好，所以多线程带来的影响也越来越小。如果一个CPU是多核的，如果不执行多任务反而是浪费了机器的性能。不过这些设计讨论是另外的话题了。简而言之，通过Selector我们可以实现单线程操作多个channel。</p>
<p>这有一幅示意图，描述了单线程处理三个channel的情况：</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710155332.png" alt="overview-selectors.png"></p>
<p><strong>Java NIO: A Thread uses a Selector to handle 3 Channel’s</strong></p>
<h4 id="如何使用selector（How-Use-a-Selector）"><a href="#如何使用selector（How-Use-a-Selector）" class="headerlink" title="如何使用selector（How Use a Selector）"></a>如何使用selector（How Use a Selector）</h4><blockquote>
<p>创建Selector(Creating a Selector)</p>
</blockquote>
<p>创建一个Selector可以通过Selector.open()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector &#x3D; Selector.open();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注册Channel到Selector上(Registering Channels with the Selector)</p>
</blockquote>
<p>为了让Selector监听Channel，我们必须先把Channel注册到Selector上，这个操作使用SelectableChannel.register()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false);</span><br><span class="line">SelectionKey key &#x3D; channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>

<p>Channel必须是非阻塞的。所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式。Socket channel可以正常使用。</p>
<p>==注意register的第二个参数==，这个参数是一个“关注集合”，代表我们关注的channel状态，有四种基础类型可供监听：</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>一个channel触发了一个事件也可视作该事件处于就绪状态。因此当channel与server连接成功后，那么就是“连接就绪”状态。server channel接收请求连接时处于“可连接就绪”状态。channel有数据可读时处于“读就绪”状态。channel可以进行数据写入时处于“写就绪”状态。</p>
<p>上述的四种就绪状态用SelectionKey中的常量表示如下：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果对多个事件感兴趣可利用位的或运算结合多个常量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int interestSet &#x3D; SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SelectionKeys</p>
</blockquote>
<p>我们利用register方法把Channel注册到了Selectors上，这个方法的返回值是SelectionKeys，这个返回的对象包含了一些比较有价值的属性：</p>
<ul>
<li>The interest set</li>
<li>The ready set</li>
<li>The Channel</li>
<li>The Selector</li>
<li>An attached object (optional)</li>
</ul>
<p>这5个属性都代表什么含义呢？下面会一一介绍。</p>
<blockquote>
<p>Interest Set</p>
</blockquote>
<p>这个“关注集合”实际上就是我们希望处理的事件的集合，它的值就是注册时传入的参数，我们可以用按为与运算把每个事件取出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int interestSet &#x3D; selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line">boolean isInterestedInAccept  &#x3D; interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line">boolean isInterestedInConnect &#x3D; interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line">boolean isInterestedInRead    &#x3D; interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line">boolean isInterestedInWrite   &#x3D; interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Ready Set</p>
</blockquote>
<p>“就绪集合”中的值是当前channel处于就绪的值，一般来说在调用了select方法后都会需要用到就绪状态，select的介绍在后续文章中继续展开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet &#x3D; selectionKey.readyOps();</span><br></pre></td></tr></table></figure>

<p>从“就绪集合”中取值的操作类似于“关注集合”的操作，当然还有更简单的方法，SelectionKey提供了一系列返回值为boolean的的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Channel + Selector</p>
</blockquote>
<p>从SelectionKey操作Channel和Selector非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  &#x3D; selectionKey.channel();</span><br><span class="line">Selector selector &#x3D; selectionKey.selector();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Attaching Objects</p>
</blockquote>
<p>我们可以给一个SelectionKey附加一个Object，这样做一方面可以方便我们识别某个特定的channel，同时也增加了channel相关的附加信息。例如，可以把用于channel的buffer附加到SelectionKey上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line"></span><br><span class="line">Object attachedObj &#x3D; selectionKey.attachment();</span><br></pre></td></tr></table></figure>

<p>附加对象的操作也可以在register的时候就执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key &#x3D; channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>

<h4 id="从Selector中选择channel-Selecting-Channels-via-a-Selector"><a href="#从Selector中选择channel-Selecting-Channels-via-a-Selector" class="headerlink" title="从Selector中选择channel(Selecting Channels via a Selector)"></a>从Selector中选择channel(Selecting Channels via a Selector)</h4><p>一旦我们向Selector注册了一个或多个channel后，就可以调用select来获取channel。select方法会返回所有处于就绪状态的channel。 select方法具体如下：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p>select()方法在返回channel之前处于阻塞状态。 select(long timeout)和select做的事一样，不过他的阻塞有一个超时限制。</p>
<p>selectNow()不会阻塞，根据当前状态立刻返回合适的channel。</p>
<p>select()方法的返回值是一个int整形，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。举例来说，假设第一次调用select时正好有一个channel就绪，那么返回值是1，并且对这个channel做任何处理，接着再次调用select，此时恰好又有一个新的channel就绪，那么返回值还是1，现在我们一共有两个channel处于就绪，但是在每次调用select时只有一个channel是就绪的。</p>
<blockquote>
<p>selectedKeys()</p>
</blockquote>
<p>在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();</span><br></pre></td></tr></table></figure>

<p>还记得在register时的操作吧，我们register后的返回值就是SelectionKey实例，也就是我们现在通过selectedKeys()方法所返回的SelectionKey。</p>
<p>遍历这些SelectionKey可以通过如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述循环会迭代key集合，针对每个key我们单独判断他是处于何种就绪状态。</p>
<p>注意keyIterater.remove()方法的调用，Selector本身并不会移除SelectionKey对象，这个操作需要我们收到执行。当下次channel处于就绪是，Selector任然会吧这些key再次加入进来。</p>
<p>SelectionKey.channel返回的channel实例需要强转为我们实际使用的具体的channel类型，例如ServerSocketChannel或SocketChannel.</p>
<blockquote>
<p>wakeUp()</p>
</blockquote>
<p>y由于调用select而被阻塞的线程，可以通过调用Selector.wakeup()来唤醒即便此时已然没有channel处于就绪状态。具体操作是，在另外一个线程调用wakeup，被阻塞与select方法的线程就会立刻返回。</p>
<blockquote>
<p>close()</p>
</blockquote>
<p>当操作Selector完毕后，需要调用close方法。close的调用会关闭Selector并使相关的SelectionKey都无效。channel本身不管被关闭。</p>
<h4 id="举个栗子-Full-Selector-Example"><a href="#举个栗子-Full-Selector-Example" class="headerlink" title="举个栗子(Full Selector Example)"></a>举个栗子(Full Selector Example)</h4><p>NIO服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//服务器端创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel =ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//创建选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//通道绑定监听端口</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置通道非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//通道绑定选择器</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//持续监听，如果没有连接</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有连接，SelectionKeys</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//遍历这些连接的selectedKeys，查看此连接的selectedKeys中包含什么事件</span></span><br><span class="line">                SelectionKey selectionKey = keyIterator.next();</span><br><span class="line">                <span class="comment">//可连接状态</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    System.out.println(<span class="string">"有新的连接"</span>);</span><br><span class="line">                    <span class="comment">//生成一个客户端的SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将客户端的SocketChannel绑定到selector上</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//用selectionKey获取客户端的SocketChannel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)selectionKey.channel();</span><br><span class="line">                    <span class="comment">//用selectionKey获取客户端的ByteBuffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)selectionKey.attachment();</span><br><span class="line">                    <span class="comment">//此时数据在channel中，将数据写入buffer中</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    <span class="comment">//显示数据</span></span><br><span class="line">                    System.out.println(<span class="string">"from客户端："</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动移除当前操作完毕的key</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端创建SocketChannel</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置SocketChannel非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!socketChannel.connect(socketAddress))&#123;</span><br><span class="line">           <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">               System.out.println(<span class="string">"连接中"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        String hello = <span class="string">"hello nic"</span>;</span><br><span class="line">        <span class="comment">//将数据放入buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(hello.getBytes());</span><br><span class="line">        <span class="comment">//buffer写入channel</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="selector、poll、epoll"><a href="#selector、poll、epoll" class="headerlink" title="selector、poll、epoll"></a>selector、poll、epoll</h3><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><ul>
<li>select的工作流程： 单个进程就可以同时处理多个网络连接的io请求（同时阻塞多个io操作）。基本原理就是程序呼叫select，然后整个程序就阻塞了，这时候，kernel就会轮询检查所有select负责的fd，当找到一个client中的数据准备好了，select就会返回，这个时候程序就会系统调用，将数据从kernel复制到进程缓冲区。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200711234418.png" alt="image.png"></p>
<p>下图为select同时从多个客户端接受数据的过程</p>
<p>虽然服务器进程会被select阻塞，但是select会利用内核不断轮询监听其他客户端的io操作是否完成。</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200711234452.png" alt="image.png"></p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><ul>
<li>poll的原理与select非常相似，差别如下：<ul>
<li>描述fd集合的方式不同，poll使用 pollfd 结构而不是select结构fd_set结构，所以poll是链式的，没有最大连接数的限制</li>
<li>poll有一个特点是水平触发，也就是通知程序fd就绪后，这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</li>
</ul>
</li>
</ul>
<blockquote>
<p>==缺点和C10K问题==</p>
</blockquote>
<ul>
<li><p>根据fd_size的定义，它的大小为32个整数大小（32位机器为32*32，所有共有1024bits可以记录fd），每个fd一个bit，所以最大只能同时处理1024个fd</p>
</li>
<li><p>每次要判断【有哪些event发生】这件事的成本很高，因为select（polling也是）采取主动轮询机制</p>
<ul>
<li>每一次呼叫 select( ) 都需要先从 user space把 FD_SET复制到 kernel（约线性时间成本） 为什么 select 不能像epoll一样，只做一次复制就好呢? 每一次呼叫 select()前，FD_SET都可能更改变动，而 epoll 提供了共享记忆存储结构，所以不需要有 kernel 与 user之间的数据沟通</li>
<li>然后kernel还要轮询每个fd，约线性时间</li>
</ul>
</li>
<li><p>假设现实中，有1百万个客户端同时与一个服务器保持着tcp连接，而每一个时刻，通常只有几百上千个tcp连接是活跃的，这时候我们仍然使用select/poll机制，kernel必须在搜寻完100万个fd之后，才能找到其中状态是active的，这样资源消耗大而且效率低下。</p>
</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><blockquote>
<p>epoll 提供了三个函数：</p>
</blockquote>
<ul>
<li>int epoll_create(int size); 建立一個 epoll 对象，并传回它的id</li>
<li>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 事件注册函数，将需要监听的事件和需要监听的fd交给epoll对象</li>
<li>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 等待注册的事件被触发或者timeout发生</li>
</ul>
<blockquote>
<p>epoll 的内部处理过程主要可以分四个步骤：</p>
</blockquote>
<ol>
<li>调用epoll_create()函数，创建epoll句柄eventpoll。该eventpoll内部包含了:一个红黑树rbtree，一个就绪链表rdlist;</li>
<li>调用epoll_ctl(EPOLL_CTL_ADD…)将所关心fd的关心事件注册到epoll的rbtree上，（当然也有可能是修改或删除），并注册关心事件的回调函数（如add函数,将就绪fd添加到rdlist）</li>
<li>一旦设备（如网卡）有关心事件发生，对应的注册回调函数被触发，就绪fd被添加到rdlist;</li>
<li>用户程序调用epoll_wait(),返回rdlist，并对其中的fd做相应处理。<br>具体过程如下图所示：</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200712000118.png" alt="img"></p>
<blockquote>
<p>epoll解决的问题：</p>
</blockquote>
<ul>
<li>epoll没有fd数量限制 epoll没有这个限制，我们知道每个epoll监听一个fd，所以最大数量与能打开的fd数量有关，一个g的内存的机器上，能打开10万个左右</li>
<li>epoll不需要每次都从user space 将fd set复制到内核kernel epoll在用epoll_ctl函数进行事件注册的时候，已经将fd复制到内核中，所以不需要每次都重新复制一次</li>
<li>select 和 poll 都是主动轮循机制，需要访问每一個 FD； epoll是被动触发方式，给fd注册了相应事件的时候，我们为每一个fd指定了一个回调函数，当数据准备好之后，就会把就绪的fd加入一个就绪的队列中，epoll_wait的工作方式实际上就是在这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数。</li>
<li>虽然selector、poll、epoll都需要查看是否有fd就绪，但是epoll之所以是被动触发，就在于它只要去查找就绪队列中有没有fd，就绪的fd是主动加到队列中，epoll不需要一个个轮询确认。 换一句话讲，就是selector和poll只能通知有fd已经就绪了，但不能知道究竟是哪个fd就绪，所以select和poll就要去主动轮询一遍找到就绪的fd。而epoll则是不但可以知道有fd可以就绪，而且还具体可以知道就绪fd的编号，所以直接找到就可以，不用轮询。</li>
</ul>
<blockquote>
<p>Epoll 的两种工作模式</p>
</blockquote>
<p>​    epoll 有 EPOLLLT 和 EPOLLET 两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。</p>
<h2 id="Netty终于来啦！！！"><a href="#Netty终于来啦！！！" class="headerlink" title="Netty终于来啦！！！"></a>Netty终于来啦！！！</h2><h3 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h3><ul>
<li>Netty 是由 JBoss 提供的一个 Java 开源框架，现在是 GitHub 上的独立项目。</li>
<li>Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠的网络 I/O。</li>
<li>Netty 主要针对在 TCP 协议下，面向 Clients端的高并发应用，本质是一个 NIO框架。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710110543.png" alt="Do java netty projects by Riyafaahf"></p>
<h3 id="Reactor-I-O-模型"><a href="#Reactor-I-O-模型" class="headerlink" title="Reactor I/O 模型"></a>Reactor I/O 模型</h3><h4 id="经典Reactor模式（单线程模式）"><a href="#经典Reactor模式（单线程模式）" class="headerlink" title="经典Reactor模式（单线程模式）"></a>经典Reactor模式（单线程模式）</h4><p>经典的Reactor模式示意图如下所示。<br><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200712231430.png" alt="image-20200712231430556"></p>
<p>在Reactor模式中，包含如下角色</p>
<ul>
<li><strong><em>Reactor</em></strong> 将I/O事件发派给对应的Handler</li>
<li><strong><em>Acceptor</em></strong> 处理客户端连接请求</li>
<li><strong><em>Handlers</em></strong> 执行非阻塞读/写</li>
</ul>
<p>最简单的Reactor模式实现代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">          SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">"Accept request from &#123;&#125;"</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">          ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">          <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">          <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">            key.cancel();</span><br><span class="line">            LOGGER.info(<span class="string">"Received invalide data, close the connection"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          LOGGER.info(<span class="string">"Received message &#123;&#125;"</span>, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">        &#125;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了方便阅读，上示代码将Reactor模式中的所有角色放在了一个类中。</p>
<p>从上示代码中可以看到，多个Channel可以注册到同一个Selector对象上，实现了一个线程同时监控多个请求状态（Channel）。同时注册时需要指定它所关注的事件，例如上示代码中<em>socketServerChannel</em>对象只注册了<em>OP_ACCEPT</em>事件，而<em>socketChannel</em>对象只注册了<em>OP_READ</em>事件。</p>
<p><code>selector.select()</code>是阻塞的，当有至少一个通道可用时该方法返回可用通道个数。同时该方法只捕获Channel注册时指定的所关注的事件。</p>
<h4 id="多工作线程Reactor模式"><a href="#多工作线程Reactor模式" class="headerlink" title="多工作线程Reactor模式"></a>多工作线程Reactor模式</h4><p>​        经典Reactor模式中，尽管一个线程可同时监控多个请求（Channel），但是所有读/写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读/写操作也会阻塞对新连接请求的处理。因此可以引入多线程，并行处理多个读/写操作，如下图所示。<br><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200712231530.png" alt="image-20200712231530732"></p>
<p>多线程Reactor模式示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(selector.selectNow() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">          SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">"Accept request from &#123;&#125;"</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          SelectionKey readKey = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          readKey.attach(<span class="keyword">new</span> Processor());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          Processor processor = (Processor) key.attachment();</span><br><span class="line">          processor.process(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        从上示代码中可以看到，注册完SocketChannel的<em>OP_READ</em>事件后，可以对相应的SelectionKey attach一个对象（本例中attach了一个Processor对象，该对象处理读请求），并且在获取到可读事件后，可以取出该对象。</p>
<p>注：attach对象及取出该对象是NIO提供的一种操作，但该操作并非Reactor模式的必要操作，本文使用它，只是为了方便演示NIO的接口。</p>
<p>具体的读请求处理在如下所示的Processor类中。该类中设置了一个静态的线程池处理所有请求。而<em>process</em>方法并不直接处理I/O请求，而是把该I/O操作提交给上述线程池去处理，这样就充分利用了多线程的优势，同时将对新连接的处理和读/写操作的处理放在了不同的线程中，读/写操作不再阻塞对新连接请求的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Processor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">      <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        selectionKey.cancel();</span><br><span class="line">        LOGGER.info(<span class="string">"&#123;&#125;\t Read ended"</span>, socketChannel);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125;\t Read message &#123;&#125;"</span>, socketChannel, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多Reactor"><a href="#多Reactor" class="headerlink" title="多Reactor"></a>多Reactor</h4><p>Netty中使用的Reactor模式，引入了多Reactor，也即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读/写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟。<br>并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel的所有操作由同一个线程处理。这样保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换，同时也方便了监控请求响应状态。</p>
<p>多Reactor模式示意图如下所示。<br><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200712231627.png" alt="image-20200712231627301"></p>
<p>多Reactor示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(NIOServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> coreNum = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    Processor[] processors = <span class="keyword">new</span> Processor[<span class="number">2</span> * coreNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processors.length; i++) &#123;</span><br><span class="line">      processors[i] = <span class="keyword">new</span> Processor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">      <span class="keyword">for</span> (SelectionKey key : keys) &#123;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">          SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">          socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">          LOGGER.info(<span class="string">"Accept request from &#123;&#125;"</span>, socketChannel.getRemoteAddress());</span><br><span class="line">          Processor processor = processors[(<span class="keyword">int</span>) ((index++) % coreNum)];</span><br><span class="line">          processor.addChannel(socketChannel);</span><br><span class="line">          processor.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如上代码所示，本文设置的子Reactor个数是当前机器可用核数的两倍（与Netty默认的子Reactor个数一致）。对于每个成功连接的SocketChannel，通过round robin的方式交给不同的子Reactor。</p>
<p>子Reactor对SocketChannel的处理如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Processor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService service =</span><br><span class="line">      Executors.newFixedThreadPool(<span class="number">2</span> * Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Processor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = SelectorProvider.provider().openSelector();</span><br><span class="line">    start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">    socketChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selector.select(<span class="number">500</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          SelectionKey key = iterator.next();</span><br><span class="line">          iterator.remove();</span><br><span class="line">          <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              socketChannel.close();</span><br><span class="line">              key.cancel();</span><br><span class="line">              LOGGER.info(<span class="string">"&#123;&#125;\t Read ended"</span>, socketChannel);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">              LOGGER.info(<span class="string">"&#123;&#125;\t Message size is 0"</span>, socketChannel);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              LOGGER.info(<span class="string">"&#123;&#125;\t Read message &#123;&#125;"</span>, socketChannel, <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        在Processor中，同样创建了一个静态的线程池，且线程池的大小为机器核数的两倍。每个Processor实例均包含一个Selector实例。同时每次获取Processor实例时均提交一个任务到该线程池，并且该任务正常情况下一直循环处理，不会停止。而提交给该Processor的SocketChannel通过在其Selector注册事件，加入到相应的任务中。由此实现了每个子Reactor包含一个Selector对象，并由一个独立的线程处理</p>
<h3 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h3><p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200713165322.png" alt="netty模型"></p>
<ol>
<li>netty 抽象出了两组线程池，BossGroup 专门负责客户端 的连接，WorkerGroup 专门负责网络读写。</li>
<li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</li>
<li>NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是一个 NioEventLoop</li>
<li>NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 selector ,用于监听绑定在其上 socket 网络通信</li>
<li>NioEventLoopGroup 可以有多个线程，即可以含有多个 NioEventLoop</li>
<li>每个 Boss 对应的 NioEvenetLoop 都会执行以下三步:<ol>
<li>轮询 accept 事件，</li>
<li>处理 accept 事件，与 client 建立 socket 连接，生成 NioSocketChannel ,并将生成的 NioSocketChannel 注册到某个worker NioEventLoop 上的 selector 上。</li>
<li>处理任务队列中的任务，即 runAllTasks</li>
</ol>
</li>
<li>每个 worker NioEventLoop 循环执行步骤：<ol>
<li>轮询 read/write 事件</li>
<li>处理 I/O 事件，即 read ,write 事件，在对应的 NioSocketChannel 处理</li>
<li>处理任务队列中的其它任务</li>
</ol>
</li>
<li>每个 worker NioEventLoop 会使用 PipeLine 管道处理，PipeLine 中包含了 Channel，即通过 PipeLine 可以获取对应的 Channel， 管道中维护了很多的处理器 Handler 。</li>
</ol>
<h4 id="Netty模型的简单实现"><a href="#Netty模型的简单实现" class="headerlink" title="Netty模型的简单实现"></a>Netty模型的简单实现</h4><ol>
<li>NettyServer</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/13 5:09 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组 BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//bossGroup线程组只处理连接请求，workerGroup 处理客户端业务</span></span><br><span class="line">        <span class="comment">//两个线程组都会无限循环</span></span><br><span class="line">        <span class="comment">//NioEventLoopGroup 中包含的子线程 NioEventLoop 默认数量是CPU数量*2</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器端启动对象 serverBootstrap，配置启动参数</span></span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                <span class="comment">//设置两个线程组,如果仅设置一个线程组，默认 BossGroup 和 WorkerGroup 共用一个</span></span><br><span class="line">                .group(bossGroup,workerGroup)</span><br><span class="line">                <span class="comment">//使用 NioSocketChannel 作为服务器通道的实现</span></span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //设置线程队列的连接个数</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>,128)</span></span><br><span class="line"><span class="class">                //设置保持连接活动状态</span></span><br><span class="line"><span class="class">                .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>,<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                //给 <span class="title">workerGroup</span> 的 <span class="title">EventLoop</span> 的对应管道设置处理器</span></span><br><span class="line"><span class="class">                //创建一个通道初始化对象</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                       <span class="comment">//此处 SocketChannel 每个客户端都不一样，可以维护一个和客户端信息绑定的集合统一管理 SocketChannel，推送消息时，可以加入到对应客户的 taskQueue 中 异步处理（channel.eventLoop.execute）</span></span><br><span class="line">                        </span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"server is ready"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定一个端口并且同步，生成一个channelFuture对象</span></span><br><span class="line">        ChannelFuture cf = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">        <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">        cf.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>NettyServerHandler</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/13 5:58 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 自定义的handler 需要继承netty规定好的 ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取实际信息（这里可以读取客户端发送的信息）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1 ChannelHandlerContext 上下文对象，含有pipeline，channel ，链接地址</span></span><br><span class="line"><span class="comment">     * 2 Object 客户端发送的数据，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"server cxt:"</span>+ ctx);</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf)msg;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"client request："</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"client address："</span>+ ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//将数据写入缓存并刷新</span></span><br><span class="line">        <span class="comment">//对发送数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello client"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般是关闭通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>NettyClient</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> sun.applet.Main;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/13 6:13 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端只需要一个事件循环组就可以了</span></span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象 使用 bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    <span class="comment">//设置线程组</span></span><br><span class="line">                    .group(eventLoopGroup)</span><br><span class="line">                    <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">"client is ready"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端,关于 ChannelFuture  涉及到 netty 的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>NettyClientHandler</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/13 5:58 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 自定义的handler 需要继承netty规定好的 ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client ctx:"</span>+ctx);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello Server"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时会触发这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">"server response:"</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"server address:"</span>+ ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty模型总结：</p>
<ol>
<li>Netty抽象出两组线程池，BossGroup 负责接收客户端连接，WorkerGroup 负责处理网络读写操作</li>
<li>NIOEventLoop 表示一个不断循环处理任务的线程，每个 NIOEventLoop 都有一个 Selector ，用于监听绑定在上面的 channel</li>
<li>内部采用串行化设计，从消息读取、解码、执行、编码、发送都是由 NIOEventLoop 完成。<ul>
<li>每个 NIOEventLoopGroup 下包含多个 NIOEventLoop</li>
<li>每个 NIOEventLoop 里有一个 Selector 和 TaskQueue</li>
<li>每个 NIOEventLoop 上的 Selector 可以注册多个 Channel</li>
<li>每个 Channel 只会绑定在唯一一个 NIOEventLoop 上</li>
<li>每个 Channel 都绑定一个自己的 Pipeline</li>
</ul>
</li>
</ol>
<h4 id="Netty异步模型"><a href="#Netty异步模型" class="headerlink" title="Netty异步模型"></a>Netty异步模型</h4><blockquote>
<p>简介</p>
</blockquote>
<ol>
<li>Netty中的 I/O 操作是异步的, 包括 Bind、Write、Connect 等操作会简单的返回一个ChannelFuture。</li>
<li>调用者不能立刻获得结果, 而是通过Future-Listener 机制, 用户可以方便的主动获取或者通过通知机制获得IO操作结果。</li>
<li>Netty的异步模型是建立在future和callback之上的。callback就是回调。</li>
<li>Future的核心思想是: 假设一个方法func(), 其计算过程可能很耗时, 等待func()返回不合适。那么就可以在调用func()的时候, 立马返回一个Future, 后续可以通过Future去监控方法func()的处理过程(即： Future-Listener机制)</li>
</ol>
<blockquote>
<p>Future 说明</p>
</blockquote>
<ol>
<li>表示异步的结果, 可以通过它提供的方法来检测执行是否完成, 比如检索计算等。</li>
<li>ChannelFuture是一个继承了Future类的接口, public interface ChannelFuture extends Future {}。可以添加监听器, 当监听的事件发生时, 就会通知到监听器。</li>
</ol>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定一个端口并且同步，生成一个channelFuture对象</span></span><br><span class="line">       ChannelFuture cf = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">       <span class="comment">//给 ChannelFuture 注册监听器</span></span><br><span class="line">           cf.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span> (future.isSuccess())&#123;</span><br><span class="line">                   System.out.println(<span class="string">"bind port 6668 is success"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>工作原理</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200713232135.png" alt="1576203568157"></p>
<ul>
<li>inBound: 入栈</li>
<li>outBound: 出栈</li>
<li>说明:<ol>
<li>在使用Netty进行编程时, 拦截操作和转换出入栈数据只需要提供callback 或 利用future即可。</li>
<li>这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。</li>
<li>Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来。</li>
</ol>
</li>
</ul>
<blockquote>
<p>ChannelFuture类注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The result of an asynchronous &#123;<span class="doctag">@link</span> Channel&#125; I/O operation.</span></span><br><span class="line"><span class="comment"> * 异步I/O操作的执行结果</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All I/O operations in Netty are asynchronous. </span></span><br><span class="line"><span class="comment"> * Netty中的所有 I/O操作都是异步的</span></span><br><span class="line"><span class="comment"> * It means any I/O calls will return immediately with no guarantee that the </span></span><br><span class="line"><span class="comment"> * requested I/O operation has been completed at the end of the call. </span></span><br><span class="line"><span class="comment"> * 这意味着 任意 I/O 调用都会直接返回, 但是不能保证请求的I/O 操作在被调用前能够完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Instead, you will be returned with a &#123;<span class="doctag">@link</span> ChannelFuture&#125; instance which gives </span></span><br><span class="line"><span class="comment"> * you the information about the result or status of the I/O operation.</span></span><br><span class="line"><span class="comment"> * 但是, 会有一个能提供该I/O操作的结果或状态的ChannelFuture类实例被返回。 </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> ChannelFuture&#125; is either &lt;em&gt;uncompleted&lt;/em&gt; or &lt;em&gt;completed&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> * channelFuture的状态可以是未完成的也可以是完成的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When an I/O operation begins, a new future object is created. </span></span><br><span class="line"><span class="comment"> * 当一个 I/O 操作开始, 一个新的对象被创建。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The new future is uncompleted initially - it is neither succeeded, failed, nor </span></span><br><span class="line"><span class="comment"> * cancelled because the I/O operation is not finished yet.  </span></span><br><span class="line"><span class="comment"> * 新的future一开始是未完成状态, 它不是成功的, 失败的, 或取消的, 因为 I/O 操作并没有完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the I/O operation is finished either successfully, with failure, or by </span></span><br><span class="line"><span class="comment"> * cancellation, the future is marked as completed with more specific information, </span></span><br><span class="line"><span class="comment"> * such as the cause of the failure.</span></span><br><span class="line"><span class="comment"> * 如果 I/O 操作是成功完成的, 失败的 或是 被取消状态, future就被标记为带有特定信息的完成状</span></span><br><span class="line"><span class="comment"> * 态, 比如导致失败的原因。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Please note that even failure and cancellation belong to the completed state.</span></span><br><span class="line"><span class="comment"> * 请记住, 即使是 失败 和 取消 都是完成状态</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *                                      +---------------------------+</span></span><br><span class="line"><span class="comment"> *                                      | Completed successfully    |</span></span><br><span class="line"><span class="comment"> *                                      +---------------------------+</span></span><br><span class="line"><span class="comment"> *                                 +----&gt;      isDone() = true      |</span></span><br><span class="line"><span class="comment"> * +--------------------------+    |    |   isSuccess() = true      |</span></span><br><span class="line"><span class="comment"> * |        Uncompleted       |    |    +===========================+</span></span><br><span class="line"><span class="comment"> * +--------------------------+    |    | Completed with failure    |</span></span><br><span class="line"><span class="comment"> * |      isDone() = false    |    |    +---------------------------+</span></span><br><span class="line"><span class="comment"> * |   isSuccess() = false    |----+----&gt;      isDone() = true      |</span></span><br><span class="line"><span class="comment"> * | isCancelled() = false    |    |    |       cause() = non-null  |</span></span><br><span class="line"><span class="comment"> * |       cause() = null     |    |    +===========================+</span></span><br><span class="line"><span class="comment"> * +--------------------------+    |    | Completed by cancellation |</span></span><br><span class="line"><span class="comment"> *                                 |    +---------------------------+</span></span><br><span class="line"><span class="comment"> *                                 +----&gt;      isDone() = true      |</span></span><br><span class="line"><span class="comment"> *                                      | isCancelled() = true      |</span></span><br><span class="line"><span class="comment"> *                                      +---------------------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Various methods are provided to let you check if the I/O operation has been</span></span><br><span class="line"><span class="comment"> * completed, wait for the completion, and retrieve the result of the I/O</span></span><br><span class="line"><span class="comment"> * operation. </span></span><br><span class="line"><span class="comment"> * 有许多方法提供给你来检查 此I/O 操作是否完成, 在等待完成, 并取回 I/O 操作的结果。</span></span><br><span class="line"><span class="comment"> * It also allows you to add &#123;<span class="doctag">@link</span> ChannelFutureListener&#125;s so you</span></span><br><span class="line"><span class="comment"> * can get notified when the I/O operation is completed.</span></span><br><span class="line"><span class="comment"> * 它还允许你添加 ChannelFuture监听器, 所以你能够在I/O 操作完成时被通知。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Prefer &#123;<span class="doctag">@link</span> #addListener(GenericFutureListener)&#125; to &#123;<span class="doctag">@link</span> #await()&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is recommended to prefer &#123;<span class="doctag">@link</span> #addListener(GenericFutureListener)&#125; to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #await()&#125; wherever possible to get notified when an I/O operation is</span></span><br><span class="line"><span class="comment"> * done and to do any follow-up tasks.</span></span><br><span class="line"><span class="comment"> * 当一个 I/O 操作被完成 并且 有接下来的任务要做时, 推荐使用 addListener(添加监听器)而不是 </span></span><br><span class="line"><span class="comment"> * await() 方法, 因为使用监听器的方式可以被通知。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #addListener(GenericFutureListener)&#125; is non-blocking.</span></span><br><span class="line"><span class="comment"> * addListener 方法是非阻塞的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It simply adds the specified &#123;<span class="doctag">@link</span> ChannelFutureListener&#125; to the &#123;<span class="doctag">@link</span> </span></span><br><span class="line"><span class="comment"> * ChannelFuture&#125;, and I/O thread will notify the listeners when the I/O operation </span></span><br><span class="line"><span class="comment"> * associated with the future is done. </span></span><br><span class="line"><span class="comment"> * 它仅仅添加了特定的ChannelFutureListener到ChannelFuture中, 并且 I/O 线程会在 与future</span></span><br><span class="line"><span class="comment"> * 相关联的 I/O 操作完成时通知监听器。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ChannelFutureListener&#125; yields the best performance and resource </span></span><br><span class="line"><span class="comment"> * utilization because it does not block at all, but it could be tricky to implement </span></span><br><span class="line"><span class="comment"> * a sequential logic if you are not used to event-driven programming.</span></span><br><span class="line"><span class="comment"> * 由于本身不阻塞, ChannelFutureListener(监听器) 能提供最好的效用 和 最好的资源利用率, 但</span></span><br><span class="line"><span class="comment"> * 是如果内没有习惯于事件启动编程模型, 实现一系列逻辑时可能会比较tricky。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By contrast, &#123;<span class="doctag">@link</span> #await()&#125; is a blocking operation.  </span></span><br><span class="line"><span class="comment"> * 相比较之下, await() 方法是一个阻塞操作。</span></span><br><span class="line"><span class="comment"> * Once called, the caller thread blocks until the operation is done.  </span></span><br><span class="line"><span class="comment"> * 一旦被调用, 在操作结束之前, 调用者线程会一直阻塞。</span></span><br><span class="line"><span class="comment"> * It is easier to implement a sequential logic with &#123;<span class="doctag">@link</span> #await()&#125;, but the </span></span><br><span class="line"><span class="comment"> * caller thread blocks unnecessarily until the I/O operation is done and there's </span></span><br><span class="line"><span class="comment"> * relatively expensive cost of inter-thread notification. </span></span><br><span class="line"><span class="comment"> * 以await() 方法实现一系列的逻辑会相对简单, 但是调用者线程在I/O操作间有不必要的阻塞 以及 </span></span><br><span class="line"><span class="comment"> * 线程内部通信代价很高。</span></span><br><span class="line"><span class="comment"> * Moreover, there's a chance of dead lock in a particular circumstance, which is </span></span><br><span class="line"><span class="comment"> * described below.</span></span><br><span class="line"><span class="comment"> * 此外, 在特殊情况下, 还有可能会产生死锁, 描述如下。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Do not call &#123;<span class="doctag">@link</span> #await()&#125; inside &#123;<span class="doctag">@link</span> ChannelHandler&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * 不要在 ChannelHandler 中调用 await() 方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The event handler methods in &#123;<span class="doctag">@link</span> ChannelHandler&#125; are usually called by</span></span><br><span class="line"><span class="comment"> * an I/O thread. </span></span><br><span class="line"><span class="comment"> * ChannelHandler中的事件处理方法通常是由 I/O 线程调用的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#123;<span class="doctag">@link</span> #await()&#125; is called by an event handler method, which is called by the </span></span><br><span class="line"><span class="comment"> * I/O thread, the I/O operation it is waiting for might never complete because</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #await()&#125; can block the I/O operation it is waiting for, which is a dead </span></span><br><span class="line"><span class="comment"> * lock.</span></span><br><span class="line"><span class="comment"> * 如果 await() 方法是被一个事件处理方法以 I/O 线程的形式调用的, 该 I/O 操作会因为await()</span></span><br><span class="line"><span class="comment"> * 方法阻塞了此 正在被等待的 I/O 操作, 从而导致死锁。</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * // BAD - NEVER DO THIS 千万别做以下操作</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Override</span>&#125;</span></span><br><span class="line"><span class="comment"> * public void channelRead(&#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; ctx, Object msg) &#123;</span></span><br><span class="line"><span class="comment"> *     &#123;<span class="doctag">@link</span> ChannelFuture&#125; future = ctx.channel().close();</span></span><br><span class="line"><span class="comment"> *     future.awaitUninterruptibly();</span></span><br><span class="line"><span class="comment"> *     // Perform post-closure operation</span></span><br><span class="line"><span class="comment"> *     // ...</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // GOOD 好的操作</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Override</span>&#125;</span></span><br><span class="line"><span class="comment"> * public void channelRead(&#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; ctx, Object msg) &#123;</span></span><br><span class="line"><span class="comment"> *     &#123;<span class="doctag">@link</span> ChannelFuture&#125; future = ctx.channel().close();</span></span><br><span class="line"><span class="comment"> *     future.addListener(new &#123;<span class="doctag">@link</span> ChannelFutureListener&#125;() &#123;</span></span><br><span class="line"><span class="comment"> *         public void operationComplete(&#123;<span class="doctag">@link</span> ChannelFuture&#125; future) &#123;</span></span><br><span class="line"><span class="comment"> *             // Perform post-closure operation</span></span><br><span class="line"><span class="comment"> *             // ...</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * In spite of the disadvantages mentioned above, there are certainly the cases</span></span><br><span class="line"><span class="comment"> * where it is more convenient to call &#123;<span class="doctag">@link</span> #await()&#125;. </span></span><br><span class="line"><span class="comment"> * 尽管await()方法的缺点已经在上列出, 还是肯定会有使用它跟方便的情况</span></span><br><span class="line"><span class="comment"> * In such a case, please make sure you do not call &#123;<span class="doctag">@link</span> #await()&#125; in an I/O </span></span><br><span class="line"><span class="comment"> * thread. </span></span><br><span class="line"><span class="comment"> * 在此情况下, 请确保你没有在I/O线程中调用await()</span></span><br><span class="line"><span class="comment"> * Otherwise, &#123;<span class="doctag">@link</span> BlockingOperationException&#125; will be raised to prevent a dead </span></span><br><span class="line"><span class="comment"> * lock.</span></span><br><span class="line"><span class="comment"> * 此外 BlockingOperationException(阻塞操作异常) 会被抛出来预防死锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Do not confuse I/O timeout and await timeout&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * 不要将 I/O 超时 和 await 超时 弄混</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The timeout value you specify with &#123;<span class="doctag">@link</span> #await(long)&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #await(long, TimeUnit)&#125;, &#123;<span class="doctag">@link</span> #awaitUninterruptibly(long)&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #awaitUninterruptibly(long, TimeUnit)&#125; are not related with I/O</span></span><br><span class="line"><span class="comment"> * timeout at all.</span></span><br><span class="line"><span class="comment"> * 你使用 await(long), await(long, TimeUnit), awaitUninterruptibly(long) 或</span></span><br><span class="line"><span class="comment"> * awaitUninterruptibly(long, TimeUnit)方法时的延时与 I/O 延迟无关。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If an I/O operation times out, the future will be marked as</span></span><br><span class="line"><span class="comment"> * 'completed with failure,' as depicted in the diagram above. </span></span><br><span class="line"><span class="comment"> * 如果 I/O 操作延时, 该future 会被标记为 完成且失败, 就像途中描述的那样。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example, connect timeout should be configured via a transport-specific </span></span><br><span class="line"><span class="comment"> * option:</span></span><br><span class="line"><span class="comment"> * 比如, 连接事件应当通过特定的传输选项配置</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * // BAD - NEVER DO THIS 不要做以下操作</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Bootstrap&#125; b = ...;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ChannelFuture&#125; f = b.connect(...);</span></span><br><span class="line"><span class="comment"> * f.awaitUninterruptibly(10, TimeUnit.SECONDS);</span></span><br><span class="line"><span class="comment"> * if (f.isCancelled()) &#123;</span></span><br><span class="line"><span class="comment"> *     // Connection attempt cancelled by user</span></span><br><span class="line"><span class="comment"> *     // 连接请求被用户取消    </span></span><br><span class="line"><span class="comment"> * &#125; else if (!f.isSuccess()) &#123;</span></span><br><span class="line"><span class="comment"> *     // You might get a NullPointerException here because the future</span></span><br><span class="line"><span class="comment"> *     // might not be completed yet.</span></span><br><span class="line"><span class="comment"> *     // 你可能会得到一个空指针, 因为该future没有被完成。   </span></span><br><span class="line"><span class="comment"> *     f.cause().printStackTrace();</span></span><br><span class="line"><span class="comment"> * &#125; else &#123;</span></span><br><span class="line"><span class="comment"> *     // Connection established successfully</span></span><br><span class="line"><span class="comment"> *     // 连接建立成功   </span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // GOOD 好的操作</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Bootstrap&#125; b = ...;</span></span><br><span class="line"><span class="comment"> * // Configure the connect timeout option.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;b.option(&#123;<span class="doctag">@link</span> ChannelOption&#125;.CONNECT_TIMEOUT_MILLIS, 10000);&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ChannelFuture&#125; f = b.connect(...);</span></span><br><span class="line"><span class="comment"> * f.awaitUninterruptibly();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Now we are sure the future is completed.</span></span><br><span class="line"><span class="comment"> * // 此时我们可以确认该future已完成</span></span><br><span class="line"><span class="comment"> * assert f.isDone();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if (f.isCancelled()) &#123;</span></span><br><span class="line"><span class="comment"> *     // Connection attempt cancelled by user</span></span><br><span class="line"><span class="comment"> *     // 连接请求被用户取消  </span></span><br><span class="line"><span class="comment"> * &#125; else if (!f.isSuccess()) &#123;</span></span><br><span class="line"><span class="comment"> *     f.cause().printStackTrace();</span></span><br><span class="line"><span class="comment"> * &#125; else &#123;</span></span><br><span class="line"><span class="comment"> *     // Connection established successfully</span></span><br><span class="line"><span class="comment"> *     // 成功建立连接  </span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="Netty-实现-HTTP-服务"><a href="#Netty-实现-HTTP-服务" class="headerlink" title="Netty 实现 HTTP 服务"></a>Netty 实现 HTTP 服务</h3><p>``//TODO`</p>
<h3 id="Netty-核心组件"><a href="#Netty-核心组件" class="headerlink" title="Netty 核心组件"></a>Netty 核心组件</h3><h4 id="Bootstrap-和-ServerBootstrap"><a href="#Bootstrap-和-ServerBootstrap" class="headerlink" title="Bootstrap 和 ServerBootstrap"></a>Bootstrap 和 ServerBootstrap</h4><p>ServerBootstrap和Bootstrap都是Netty的启动类，他们的主要作用就是配置相关参数(IP，端口等)并启动整个Netty服务，不同的是ServerBootstrap用于服务端服务启动，Bootstrap用于客户端。</p>
<blockquote>
<p>常用方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法用于服务器端， 用来设置两个 EventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span>，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//该方法用于客户端，用来设置一个 EventLoop</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> ，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//该方法用来设置一个服务器端的通道实现</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span>，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用来给 ServerChannel 添加配置 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span>，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用来给接收到的通道添加配置 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ServerBootstrap <span class="title">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span>，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//该方法用来设置业务处理类（自定义的 handler） </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span>， </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//该方法用于服务器端，用来设置占用的端口号 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> ，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//该方法用于客户端，用来连接服务器端</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span></span></span><br></pre></td></tr></table></figure>





<h4 id="EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="EventLoopGroup 和其实现类 NioEventLoopGroup"></a>EventLoopGroup 和其实现类 NioEventLoopGroup</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 BossGroup 和 WorkerGroup</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line"><span class="comment">// 2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup 完成</span></span><br><span class="line"><span class="comment">// 3. 两个都是无限循环</span></span><br><span class="line"><span class="comment">// 4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line"><span class="comment">// 默认实际 cpu 核数 * 2</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。</p>
</li>
<li><p>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。在 Netty 服 务 器 端 编 程 中 ， 我 们 一 般 都 需 要 提 供 两 个 EventLoopGroup ， 例 如 ： BossEventLoopGroup 和 WorkerEventLoopGroup。</p>
</li>
<li><p>通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个 EventLoop 线程。BossEventLoop 负责 接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示</p>
</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200715000247.png" alt="image-20200715000246988"></p>
<ol start="4">
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 断开连接，关闭线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;?&gt; <span class="title">shutdownGracefully</span><span class="params">()</span>，</span></span><br></pre></td></tr></table></figure>





</li>
</ol>
<h4 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h4><ol>
<li><p>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</p>
</li>
<li><p>当向一个 Selector 中注册 Channel 后， Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个 线程高效地管理多个 Channel</p>
</li>
</ol>
<h4 id="任务队列TaskQueue"><a href="#任务队列TaskQueue" class="headerlink" title="任务队列TaskQueue"></a>任务队列TaskQueue</h4><p>为了防止非常耗时的任务造成阻塞，任务队列中的 Task 有三种典型使用场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读取实际信息（这里可以读取客户端发送的信息）</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 1 ChannelHandlerContext 上下文对象，含有pipeline，channel ，链接地址</span></span><br><span class="line"><span class="comment">   * 2 Object 客户端发送的数据，</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//比如这里有一个非常耗时的业务，需要异步执行，提交到这个 channel 对应的 NIOEventLoop 的 taskQueue中</span></span><br><span class="line"></span><br><span class="line">      Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"this is a long time event"</span>);</span><br><span class="line">      System.out.println(<span class="string">"server cxt:"</span>+ ctx);</span><br><span class="line"></span><br><span class="line">      ByteBuf buf = (ByteBuf)msg;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"client request："</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">      System.out.println(<span class="string">"client address："</span>+ ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>用户自定义的普通任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方案1：用户自定义的普通任务</span></span><br><span class="line"></span><br><span class="line">       ctx.channel().eventLoop().execute(()-&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            		System.out.println(<span class="string">"this is a long time event"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>taskQueue是线程队列，会按照入栈顺序执行。</p>
<ol start="2">
<li>用户自定义定时任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方案2：用户自定义定时任务，此时任务放在 scheduleTaskQueue中</span></span><br><span class="line">       ctx.channel().eventLoop().schedule(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            		System.out.println(<span class="string">"this is a long time event"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>非当前 Reactor 线程调用 channel 的各种方法。</li>
</ol>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>1) Netty 网络通信的组件，能够用于执行网络 I/O 操作。</p>
<p>2) 通过 Channel 可获得当前网络连接的通道的状态</p>
<p>3) 通过 Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）</p>
<p>4) Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返 回，并且不保证在调用结束时所请求的 I/O 操作已完成</p>
<p>5) 调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取 消时回调通知调用方</p>
<p>6) 支持关联 I/O 操作与对应的处理程序</p>
<p>7) 不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型:</p>
<ul>
<li>NioSocketChannel，异步的客户端 TCP Socket 连接。</li>
<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</li>
<li>NioDatagramChannel，异步的 UDP 连接。</li>
<li>NioSctpChannel，异步的客户端 Sctp 连接。</li>
<li>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</li>
</ul>
<h4 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h4><p>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功 或失败时监听会自动触发注册的监听事件</p>
<blockquote>
<p>常用方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回当前正在进行 IO 操作的通道</span></span><br><span class="line"><span class="function">Channel <span class="title">channel</span><span class="params">()</span>，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//等待异步操作执行完毕</span></span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span>，</span></span><br></pre></td></tr></table></figure>



<h4 id="ChannelHandler-及其实现类"><a href="#ChannelHandler-及其实现类" class="headerlink" title="ChannelHandler 及其实现类"></a>ChannelHandler 及其实现类</h4><ol>
<li><p>ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链) 中的下一个处理程序。</p>
</li>
<li><p>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它 的子类</p>
</li>
<li><p>ChannelHandler主要子接口：</p>
<ol>
<li>ChannelInboundHandler 入栈处理子接口</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200714000221.png" alt="img"></p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200714000324.png" alt="image-20200714000324486"></p>
</li>
</ol>
<ol start="2">
<li><p>ChannelOutboundHandler 出栈处理子接口</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200714000408.png" alt="img"></p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200714000433.png" alt="image-20200714000433322"></p>
</li>
</ol>
<p>为了便利，框架提供了ChannelInboundHandlerAdapter，ChannelOutboundHandlerAdapter和ChannelDuplexHandler这三个适配类提供一些默认实现，在使用的时候只需要实现你关注的方法即可</p>
<p>注意到一些回调方法有ChannelPromise这个参数，我们可以调用它的addListener注册监听，当回调方法所对应的操作完成后，会触发这个监听 下面这个代码，会在写操作完成后触发，完成操作包括成功和失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.write(msg,promise);</span><br><span class="line">    System.out.println(<span class="string">"out write"</span>);</span><br><span class="line">    promise.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(future.isSuccess())&#123;</span><br><span class="line">                System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ChannelInboundHandler 和 ChannelOutboundHandler 的区别</p>
</blockquote>
<p>​        个人感觉in和out的区别主要在于ChannelInboundHandler的channelRead和channelReadComplete回调和ChannelOutboundHandler的write和flush回调上，ChannelOutboundHandler的channelRead回调负责执行入栈数据的decode逻辑，ChannelOutboundHandler的write负责执行出站数据的encode工作。其他回调方法和具体触发逻辑有关，和in与out无关。</p>
<h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据读取完毕</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// writeAndFlush 是 write + flush</span></span><br><span class="line">     <span class="comment">// 将数据写入到缓存，并刷新</span></span><br><span class="line">     <span class="comment">// 一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">     ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵"</span>, CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>1) 保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象</p>
<p>2) 即 ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用.</p>
<p>3) 常用方法</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200714000956.png" alt="Xnip2020-03-31_16-13-27"></p>
<p>==每个ChannelHandlerContext之间形成双向链表==</p>
<h4 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h4><p>==ChannelPipeline== 是一个重点：</p>
<p>1) ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于 一个贯穿 Netty 的链。(也可以这样理解：ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作)</p>
<p>2) ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互</p>
<p>3) 在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200714234807.png" alt="Xnip2020-03-31_16-06-58"></p>
<p><strong>从上面可以看到这就是一个链条，也可以说是业务经过这一系列的handler的处理。</strong></p>
<p>4) 常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把一个业务处理类（handler）添加到链中的第一个位置 </span></span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(ChannelHandler... handlers)</span>，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//把一个业务处理类（handler）添加到链中的最后一个位置</span></span></span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span>，</span></span><br></pre></td></tr></table></figure>

<p>代码展示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用链式编程来进行设置</span></span><br><span class="line">    bootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">       .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) // 使用 <span class="title">NioSocketChannel</span> 作为服务器的通道实现</span></span><br><span class="line"><span class="class">       .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128) // 设置线程队列得到连接个数</span></span><br><span class="line"><span class="class">       .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>) // 设置保持活动连接状态</span></span><br><span class="line"><span class="class">       .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;<span class="comment">// 创建一个通道测试对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">// 给 pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            </span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的 workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br></pre></td></tr></table></figure>



<h4 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用链式编程来进行设置</span></span><br><span class="line">    bootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">       .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) // 使用 <span class="title">NioSocketChannel</span> 作为服务器的通道实现</span></span><br><span class="line"><span class="class">       .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128) // 设置线程队列得到连接个数</span></span><br><span class="line"><span class="class">       .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>) // 设置保持活动连接状态</span></span><br><span class="line"><span class="class">       .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;<span class="comment">// 创建一个通道测试对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">// 给 pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            </span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的 workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。</p>
</li>
<li><p>ChannelOption 参数如下:</p>
</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200714235748.png" alt="Xnip2020-03-31_16-14-54"></p>
<h4 id="ByteBuf分类及其使用"><a href="#ByteBuf分类及其使用" class="headerlink" title="ByteBuf分类及其使用"></a>ByteBuf分类及其使用</h4><blockquote>
<p>ByteBuf 简介</p>
</blockquote>
<p>在网络上传输的数据形式为Byte，Java NIO提供了ByteBuffer来作为Byte容器，该类有些复杂，而Netty使用ByteBuf作为ByteBuffer的替换方案，其提供了一个更好的API</p>
<p>　　Netty通过ByteBuf和ByteBufHolder两个组件处理数据，而ByteBuf的API有如下优势</p>
<ul>
<li>可扩展的用户定义的缓冲区类型</li>
<li>通过内置复合缓冲区类型实现透明零拷贝</li>
<li>容量随着需求可扩大</li>
<li>在读写器模式之间切换不需要调用ByteBuffer的flip（）方法</li>
<li>数据读写使用不同的索引</li>
<li>支持方法链</li>
<li>支持引用计数</li>
<li>支持池</li>
</ul>
<blockquote>
<p>ByteBuf 数据结构</p>
</blockquote>
<p>首先通过官方给出的结构图直观感受下ByteBuf的内存结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">| discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">|                   |     (CONTENT)    |                  |</span><br><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|                   |                  |                  |</span><br><span class="line"><span class="number">0</span>      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br></pre></td></tr></table></figure>

<p>接下来解释一下这些名词：</p>
<ul>
<li>discardable bytes：已经被读取过的数据，一般情况下可以理解为无效区域。</li>
<li>readable bytes：未读取数据，readable bytes数据区的数据是满的，都是等待读取的数据。</li>
<li>writable bytes：空闲区域，可以往这块区域写数据。</li>
<li>capacity：表示当前内存容量。</li>
<li>readerIndex：读数据起点指针，当需要读数据时，就以当前指针为起点往后读取数据。</li>
<li>writerIndex：写数据起点指针，当需要写数据时，就以当前指针为起点往后写数据。</li>
</ul>
<blockquote>
<p>ByteBuf使用模式</p>
</blockquote>
<p>总体分类划分是可根据JVM堆内存来区分的。</p>
<ol>
<li>堆内内存（JVM堆空间内）</li>
<li>堆外内存（本机直接内存）</li>
<li>复合缓冲区（以上2种缓冲区多个混合）</li>
</ol>
<p><strong>1.堆内内存</strong></p>
<p>最常用的ByteBuf模式是将<strong>数据存储在JVM的堆空间中</strong>。它能在没有使用池化的情况下提供快速的分配和释放。</p>
<p><strong>2.堆外内存</strong></p>
<p><strong>JDK允许JVM实现通过本地调用来分配内存。</strong>主要是为了避免每次调用本地I/O操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。<br><strong>最大的特点:它的内容将驻留在常规的会被垃圾回收的堆之外。 最大的缺点：相对于堆缓冲区，它的分配和释放都是较为昂贵的。</strong></p>
<p><strong>3.复合缓冲区</strong></p>
<p>常用类：CompositeByteBuf，它为多个ByteBuf提供一个聚合视图，<strong>将多个缓冲区表示为单个合并缓冲区的虚拟表示。</strong><br>比如：HTTP协议：头部和主体这两部分由应用程序的不同模块产生。这个时候把这两部分合并的话，选择CompositeByteBuf是比较好的。</p>
<blockquote>
<p>ByteBuf 分类</p>
</blockquote>
<ul>
<li><strong>Pooled和Unpooled</strong><br>Pooled：每次都从预先分配好的内存中去取出一段连续内存封装成一个ByteBuf给应用程序使用<br>Unpooled：每次分配内存的时候，直接调用系统api，向操作系统申请一<br>块内存</li>
<li><strong>Heap和Direct:</strong><br>Head：是调用jvm的堆内存进行分配的，需要被gc进行管理<br>Direct：是调用jdk的api进行内存分配，不受jvm控制，不会参与到gc的过程</li>
<li><strong>Unsafe和非Unsafe</strong><br>jdk中有Unsafe对象可以直接拿到对象的内存地址，并且基于这个内存地址进行读写操作。那么对应的分类的区别就是是否可以拿到jdk底层的Unsafe进行读写操作了。</li>
</ul>
<h4 id="Unpooled-类"><a href="#Unpooled-类" class="headerlink" title="Unpooled 类"></a>Unpooled 类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据读取完毕</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// writeAndFlush 是 write + flush</span></span><br><span class="line">       <span class="comment">// 将数据写入到缓存，并刷新</span></span><br><span class="line">       <span class="comment">// 一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">       ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵"</span>, CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>1) Netty 提供一个专门用来操作缓冲区(即 Netty 的数据容器)的工具类</p>
<p>2) 常用方法如下所示</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200715001534.png" alt="Xnip2020-03-31_16-19-51"></p>
<p>3) 举例说明 Unpooled 获取 Netty 的数据容器 ByteBuf 的基本使用 【案例演示】</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200715001534.png" alt="Xnip2020-03-31_16-20-11"></p>
<p><strong>案例 1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.groupchart;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/15 10:16 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 ByteBuf</span></span><br><span class="line">        <span class="comment">// 1. 创建 对象，该对象包含一个数组 arr , 是一个 byte[10]</span></span><br><span class="line">        <span class="comment">// 2. 在 netty 的 buffer 中，不需要使用 flip 进行反转 底层维护了 readerindex 和 writerIndex</span></span><br><span class="line">        <span class="comment">// 3. 通过 readerindex 和 writerIndex 和 capacity， 将 buffer 分成三个区域</span></span><br><span class="line">        <span class="comment">// 0---readerindex 已经读取的区域</span></span><br><span class="line">        <span class="comment">// readerindex---writerIndex ， 可读的区域</span></span><br><span class="line">        <span class="comment">// writerIndex -- capacity, 可写的区域</span></span><br><span class="line"></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"capacity="</span> + buffer.capacity());<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：它和NIO的ByteBuffer有区别，它是可以读和写的，不需要flip进行反转的。因为他的读和写下标是分开处理的</strong></p>
<h4 id="Netty-群聊系统简单实现"><a href="#Netty-群聊系统简单实现" class="headerlink" title="Netty 群聊系统简单实现"></a>Netty 群聊系统简单实现</h4><p>栗子：</p>
<ol>
<li>NettyChatServer</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.groupchart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/15 9:58 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(boss,worker)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>,128)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>,<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyChatServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">"server is running"</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(port).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NettyChatServer(<span class="number">8888</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>NettyChatServerHandler</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.groupchart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.VariableElement;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/15 10:16 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个channel组，管理所有channel</span></span><br><span class="line"><span class="comment">     * GlobalEventExecutor.INSTANCE 是一个全局的事件执行器，单例的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup  channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handlerAdded 表示一旦有连接建立，立即被执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将当前channel加入到 channelGroup</span></span><br><span class="line">        channelGroup.add(ctx.channel());</span><br><span class="line">        <span class="comment">//将该客户 加入聊天的信息推送给别的用户</span></span><br><span class="line">        <span class="comment">//writeAndFlush 将当前channelGroup中的所欲channel遍历并发送消息</span></span><br><span class="line">        channelGroup.writeAndFlush(LocalDateTime.now()+<span class="string">"-[client]"</span>+ctx.channel().remoteAddress()+<span class="string">"is joining"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel处于活跃状态，提示上线信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(LocalDateTime.now()+<span class="string">"-client"</span>+ctx.channel().remoteAddress()+<span class="string">" up"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel处于非活跃状态，提示下线信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(LocalDateTime.now()+<span class="string">"-client"</span>+ctx.channel().remoteAddress()+<span class="string">" down"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel断开连接，提示所有用户,自动会去掉当前channelGroup 中的 记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       channelGroup.writeAndFlush(LocalDateTime.now()+<span class="string">"-"</span>+ctx.channel().read()+<span class="string">"离开了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//遍历channelGroup，根据不同情况回复不同消息</span></span><br><span class="line">        channelGroup.forEach(ch -&gt;&#123;</span><br><span class="line">            <span class="comment">//如果不是当前通道自己</span></span><br><span class="line">                <span class="keyword">if</span> (ch != channel)&#123;</span><br><span class="line">                    <span class="comment">//转发信息</span></span><br><span class="line">                    ch.writeAndFlush(LocalDateTime.now()+<span class="string">"-client"</span>+channel.remoteAddress()+<span class="string">" send:"</span>+msg+<span class="string">"\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ch.writeAndFlush(LocalDateTime.now()+<span class="string">"-my send:"</span>+msg+<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>NettyChatClient</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.groupchart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/15 10:49 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//得到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动,创建连接</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host,port).sync();</span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"----"</span>+channel.localAddress()+<span class="string">"----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//客户端需要输入，创建扫描器</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                channel.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> NettyChatClient(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>).run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>NettyChatClientHandler</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nettypro.nettypro.groupchart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/15 11:02 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.toString().trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Netty心跳检测机制栗子"><a href="#Netty心跳检测机制栗子" class="headerlink" title="Netty心跳检测机制栗子"></a>Netty心跳检测机制栗子</h4><ol>
<li>MyServer</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/15 11:02 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">// 加入日志</span></span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">// 加入一个 netty 提供 IdleStateHandler</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 说明 </span></span><br><span class="line"><span class="comment">                     * 1. IdleStateHandler 是 netty 提供的处理空闲状态的处理器 </span></span><br><span class="line"><span class="comment">                     * 2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                     * 3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接 </span></span><br><span class="line"><span class="comment">                     * 4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                     * 5. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个 handler 去处理,通过调用(触发)下一个 handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读 空闲，写空闲，读写空闲)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">13</span>,<span class="number">5</span>,<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">                    <span class="comment">//加入一个对空闲检测进一步处理的 handler(自定义)</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器 </span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync(); </span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            bossGroup.shutdownGracefully(); </span><br><span class="line">            workerGroup.shutdownGracefully();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>MyServerHandler</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhanggqk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: Created in 2020/7/15 11:02 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="comment">// 将 evt 向下转型 IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">"--超时时间--"</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理.."</span>);</span><br><span class="line">            <span class="comment">// 如果发生空闲，我们关闭通道</span></span><br><span class="line">            <span class="comment">// ctx.channel().close();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">NicZSAMA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gakkisama.com/2020/07/10/Netty/">http://gakkisama.com/2020/07/10/Netty/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gakkisama.com" target="_blank">o.0</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200728142021.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/"><img class="prev-cover" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200723224703.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">红黑树</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/05/Dubbo/"><img class="next-cover" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200723224858.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dubbo</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By NicZSAMA</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>
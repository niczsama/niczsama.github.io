<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis 数据结构 | o.0</title><meta name="author" content="NicZSAMA"><meta name="copyright" content="NicZSAMA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Redis 简介 “Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.” —— Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 (摘自官网)  Redis 是一个开源，">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 数据结构">
<meta property="og:url" content="http://gakkisama.com/2020/07/09/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="o.0">
<meta property="og:description" content="一、Redis 简介 “Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.” —— Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 (摘自官网)  Redis 是一个开源，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226113253.png">
<meta property="article:published_time" content="2020-07-09T07:45:45.837Z">
<meta property="article:modified_time" content="2021-02-26T03:44:22.367Z">
<meta property="article:author" content="NicZSAMA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226113253.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gakkisama.com/2020/07/09/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-02-26 11:44:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226113253.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">o.0</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis 数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-09T07:45:45.837Z" title="发表于 2020-07-09 15:45:45">2020-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-26T03:44:22.367Z" title="更新于 2021-02-26 11:44:22">2021-02-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Redis-简介"><a href="#一、Redis-简介" class="headerlink" title="一、Redis 简介"></a>一、Redis 简介</h1><blockquote>
<p><strong>“Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.”</strong> —— Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 <em>(摘自官网)</em></p>
</blockquote>
<p><strong>Redis</strong> 是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的 Web 应用程序。<strong>Redis</strong> 也被作者戏称为 <em>数据结构服务器</em> ，这意味着使用者可以通过一些命令，基于带有 TCP 套接字的简单 <em>服务器-客户端</em> 协议来访问一组 <strong>可变数据结构</strong> 。<em>(在 Redis 中都采用键值对的方式，只不过对应的数据结构不一样罢了)</em></p>
<h2 id="Redis-的优点"><a href="#Redis-的优点" class="headerlink" title="Redis 的优点"></a>Redis 的优点</h2><p>以下是 Redis 的一些优点：</p>
<ul>
<li><strong>异常快</strong> - Redis 非常快，每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。</li>
<li><strong>支持丰富的数据类型</strong> - Redis 支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得 Redis 很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。</li>
<li><strong>操作具有原子性</strong> - 所有 Redis 操作都是原子操作，这确保如果两个客户端并发访问，Redis 服务器能接收更新的值。</li>
<li><strong>多实用工具</strong> - Redis 是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis 本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。</li>
</ul>
<h2 id="Redis-的安装"><a href="#Redis-的安装" class="headerlink" title="Redis 的安装"></a>Redis 的安装</h2><p>这一步比较简单，你可以在网上搜到许多满意的教程，这里就不再赘述。</p>
<h2 id="测试本地-Redis-性能"><a href="#测试本地-Redis-性能" class="headerlink" title="测试本地 Redis 性能"></a>测试本地 Redis 性能</h2><p>当安装完成之后，你可以先执行 <code>redis-server</code> 让 Redis 启动起来，然后运行命令 <code>redis-benchmark -n 100000 -q</code> 来检测本地同时执行 10 万个请求时的性能,以下是我在本机 docker 环境的测试结果：</p>
<p><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226111005.png" alt="image-20210226111005937"></p>
<h1 id="二、Redis-五种基本数据结构"><a href="#二、Redis-五种基本数据结构" class="headerlink" title="二、Redis 五种基本数据结构"></a>二、Redis 五种基本数据结构</h1><p><strong>Redis</strong> 有 5 种基础数据结构，它们分别是：<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 和 <strong>zset(有序集合)</strong>。这 5 种是 Redis 相关知识中最基础、最重要的部分。</p>
<h2 id="1）字符串-string"><a href="#1）字符串-string" class="headerlink" title="1）字符串 string"></a>1）字符串 string</h2><p>Redis 中的字符串是一种 <strong>动态字符串</strong>，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 <strong>ArrayList</strong>，有一个字符数组，从源码的 <strong>sds.h/sdshdr 文件</strong> 中可以看到 Redis 底层对于字符串的定义 <strong>SDS</strong>，即 <em>Simple Dynamic String</em> 结构：</p>
<img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226111233.png" alt="image-20210226111229129" style="zoom:50%;" />

<ul>
<li>Redis 没有直接使用 C 语言的字符串，而是构建了自己的抽象类型简单动态字符串（simple dynamic string）。<br>在 Redis 中，对于所有键，都是字符串类型，其底层实现是 SDS，而键值对的值，其实最终都是以字符串为粒度的，底层都是 SDS 实现。（比如列表，其实列表中每一项都是字符串以 SDS 实现的）。</li>
</ul>
<img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226111631.png" alt="image-20210226111631549" style="zoom:50%;" />



<ul>
<li>SDS 结构中，包含 char 类型的数组 buf ，每个位置存储字符，最后一个位置存储空字符 ‘\0’。另外，还有 free 属性和 len 属性。free 属性的值代表未使用空间的大小，len 属性代表目前保存的字符串的实际长度，结尾的 ‘\0’ 空字符不计算在内。</li>
<li>SDS 的优势： <ul>
<li>C 语言的字符串不会记录自己的长度，而是需要进行遍历获得，时间复杂度为 O(n) ，而 SDS 已经封装了 len 属性，直接读取 len 的值就可以获得长度，不需要遍历，时间复杂度 O(1) 。 </li>
<li>C 语言字符串修改时，有可能发生缓冲区溢出；而 SDS 要修改时，API 会先检查 SDS 的空间是否满足修改的要求，如果不满足，会将 SDS 的空间扩展至执行修改的所需的大小，然后才执行实际的修改操作。</li>
</ul>
</li>
</ul>
<h3 id="SDS-的优化策略"><a href="#SDS-的优化策略" class="headerlink" title="SDS 的优化策略"></a>SDS 的优化策略</h3><ul>
<li><p>空间预分配<br>空间预分配，用于优化 SDS 的字符串增长操作，当 SDS 的 API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会为 SDS 分配额外的未使用空间。（这个有点类似于 Java 中的 ArrayList 的空间每次增长扩大为之前 1.5 倍大小，进行额外的空间预分配）。<br>具体的分配规则： </p>
<ul>
<li>如果修改后的 SDS 长度 len 小于 1MB，那么程序分配和 len 属性相等的未使用空间，此时 free 和 len 的值相同。所以此时数组的实际长度为 free + len + 1byte（额外的空字符 1 个字节）。 </li>
<li>如果修改后的 SDS 长度大于 1MB，那么程序分配 1MB 的未使用空间。实际长度为 len + 1MB + 1byte。<br>在扩展 SDS 之前，会检查未使用空间是否够用，如果足够，就不用内存重分配，直接使用剩余空间即可。</li>
</ul>
</li>
<li><p>惰性空间释放<br>惰性空间释放，用于优化 SDS 的字符串缩短操作，当 SDS 的 API 对一个 SDS 进行缩短时，并不会立即使用内存重分配来回收多出来的字节，而是使用 free 属性将这些字节的数量记录下来，等待将来使用。<br>通过此策略，可以避免内存重分配，同时将来增长操作也有空间。<br>同时 SDS 也有相应的 API ，用来真正释放未使用空间，不用担心内存的浪费。</p>
</li>
<li><p>二进制存储<br>在 C 语言字符串中，’\0’ 空字符会被认为是字符串的结束，如果二进制数据中有该字符的存在，会被认为是字符串的结尾。而 SDS 由于有 len 属性的存在，使用 len 来判断字符串是否结束，而不是空字符。这样就避免了二进制数据的问题，可以用来保存图片，音频，视频等文件的二进制数据。</p>
</li>
</ul>
<h3 id="对字符串的基本操作"><a href="#对字符串的基本操作" class="headerlink" title="对字符串的基本操作"></a>对字符串的基本操作</h3><p>安装好 Redis，我们可以使用 <code>redis-cli</code> 来对 Redis 进行命令行的操作，当然 Redis 官方也提供了在线的调试器，你也可以在里面敲入命令进行操作：<a href="http://try.redis.io/#run" target="_blank" rel="noopener">http://try.redis.io/#run</a></p>
<h4 id="设置和获取键值对"><a href="#设置和获取键值对" class="headerlink" title="设置和获取键值对"></a>设置和获取键值对</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SET key value</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">"value"</span><br></pre></td></tr></table></figure>

<p>正如你看到的，我们通常使用 <code>SET</code> 和 <code>GET</code> 来设置和获取字符串值。</p>
<p>值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 <code>.jpeg</code> 图片，只需要注意不要超过 512 MB 的最大限度就好了。</p>
<p>当 key 存在时，<code>SET</code> 命令会覆盖掉你上一次设置的值：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SET key newValue</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">"newValue"</span><br></pre></td></tr></table></figure>

<p>另外你还可以使用 <code>EXISTS</code> 和 <code>DEL</code> 关键字来查询是否存在和删除键值对：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> EXISTS key</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DEL key</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h4 id="批量设置键值对"><a href="#批量设置键值对" class="headerlink" title="批量设置键值对"></a>批量设置键值对</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SET key1 value1</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET key2 value2</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MGET key1 key2 key3    <span class="comment"># 返回一个列表</span></span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br><span class="line">3) (nil)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MSET key1 value1 key2 value2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MGET key1 key2</span></span><br><span class="line">1) "value1"</span><br><span class="line">2) "value2"</span><br></pre></td></tr></table></figure>

<h4 id="过期和-SET-命令扩展"><a href="#过期和-SET-命令扩展" class="headerlink" title="过期和 SET 命令扩展"></a>过期和 SET 命令扩展</h4><p>可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。<em>(过期可以是任意数据结构)</em></p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SET key value1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">"value1"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EXPIRE name 5    <span class="comment"># 5s 后过期</span></span></span><br><span class="line">...                # 等待 5s</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>等价于 <code>SET</code> + <code>EXPIRE</code> 的 <code>SETEX</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SETEX key value1</span></span><br><span class="line">...                # 等待 5s 后获取</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SETEX key value1  <span class="comment"># 如果 key 不存在则 SET 成功</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SETEX key value1  <span class="comment"># 如果 key 存在则 SET 失败</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET key</span></span><br><span class="line">"value"             # 没有改变</span><br></pre></td></tr></table></figure>

<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>如果 value 是一个整数，还可以对它使用 <code>INCR</code> 命令进行 <strong>原子性</strong> 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SET counter 100</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCR count</span></span><br><span class="line">(interger) 101</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCRBY counter 50</span></span><br><span class="line">(integer) 151</span><br></pre></td></tr></table></figure>

<h4 id="返回原值的-GETSET-命令"><a href="#返回原值的-GETSET-命令" class="headerlink" title="返回原值的 GETSET 命令"></a>返回原值的 GETSET 命令</h4><p>对字符串，还有一个 <code>GETSET</code> 比较让人觉得有意思，它的功能跟它名字一样：为 key 设置一个值并返回原值：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SET key value</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GETSET key value1</span></span><br><span class="line">"value"</span><br></pre></td></tr></table></figure>

<p>这可以对于某一些需要隔一段时间就统计的 key 很方便的设置和查看，例如：系统每当由用户进入的时候你就是用 <code>INCR</code> 命令操作一个 key，当需要统计时候你就把这个 key 使用 <code>GETSET</code> 命令重新赋值为 0，这样就达到了统计的目的。</p>
<h2 id="2）列表-list"><a href="#2）列表-list" class="headerlink" title="2）列表 list"></a>2）列表 list</h2><p>Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>
<p>我们可以从源码的 <code>adlist.h/listNode</code> 来看到对其的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">COPY<span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，多个 listNode 可以通过 <code>prev</code> 和 <code>next</code> 指针组成双向链表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis（1）——5种基本数据结构/7896890-8f569f06506845c1.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-8f569f06506845c1.png" alt="img"></a></p>
<p>虽然仅仅使用多个 listNode 结构就可以组成链表，但是使用 <code>adlist.h/list</code> 结构来持有链表的话，操作起来会更加方便：</p>
<p><a href="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis（1）——5种基本数据结构/7896890-c6fb10cdbb32f517.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-c6fb10cdbb32f517.png" alt="img"></a></p>
<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><ul>
<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>
<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>
<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>
</ul>
<p>示范：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> rpush mylist A</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush mylist B</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lpush mylist first</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange mylist 0 -1    <span class="comment"># -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有</span></span></span><br><span class="line">1) "first"</span><br><span class="line">2) "A"</span><br><span class="line">3) "B"</span><br></pre></td></tr></table></figure>

<h4 id="list-实现队列"><a href="#list-实现队列" class="headerlink" title="list 实现队列"></a>list 实现队列</h4><p>队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> RPUSH books python java golang</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LPOP books</span></span><br><span class="line">"python"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LPOP books</span></span><br><span class="line">"java"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LPOP books</span></span><br><span class="line">"golang"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LPOP books</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h4 id="list-实现栈"><a href="#list-实现栈" class="headerlink" title="list 实现栈"></a>list 实现栈</h4><p>栈是先进后出的数据结构，跟队列正好相反：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> RPUSH books python java golang</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RPOP books</span></span><br><span class="line">"golang"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RPOP books</span></span><br><span class="line">"java"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RPOP books</span></span><br><span class="line">"python"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RPOP books</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h2 id="3）字典-hash"><a href="#3）字典-hash" class="headerlink" title="3）字典 hash"></a>3）字典 hash</h2><p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。源码定义如 <code>dict.h/dictht</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">COPYtypedef <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 内部有两个 dictht 结构</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>table</code> 属性是一个数组，数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针，而每个 <code>dictEntry</code> 结构保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">COPYtypedef <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>可以从上面的源码中看到，<strong>实际上字典结构的内部包含两个 hashtable</strong>，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 <strong>渐进式搬迁</strong> <em>(下面说原因)</em>。</p>
<img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226112620.png" alt="image-20210226112620406" style="zoom:50%;" />

<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 <strong>渐进式 rehash</strong> 小步搬迁：</p>
<p><a href="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis（1）——5种基本数据结构/7896890-325d968300c47100.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226112814.png" alt="img"></a></p>
<p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。</p>
<h3 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h3><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p>
<p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p>
<h3 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h3><p>hash 也有缺点，hash 结构的存储消耗要高于单个字符串，所以到底该使用 hash 还是字符串，需要根据实际情况再三权衡：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> HSET books java <span class="string">"think in java"</span>    <span class="comment"># 命令行的字符串如果包含空格则需要使用引号包裹</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HSET books python <span class="string">"python cookbook"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HGETALL books    <span class="comment"># key 和 value 间隔出现</span></span></span><br><span class="line">1) "java"</span><br><span class="line">2) "think in java"</span><br><span class="line">3) "python"</span><br><span class="line">4) "python cookbook"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HGET books java</span></span><br><span class="line">"think in java"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HSET books java <span class="string">"head first java"</span>  </span></span><br><span class="line">(integer) 0        # 因为是更新操作，所以返回 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HMSET books java <span class="string">"effetive  java"</span> python <span class="string">"learning python"</span>    <span class="comment"># 批量操作</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="4）集合-set"><a href="#4）集合-set" class="headerlink" title="4）集合 set"></a>4）集合 set</h2><p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>
<h3 id="集合-set-的基本使用"><a href="#集合-set-的基本使用" class="headerlink" title="集合 set 的基本使用"></a>集合 set 的基本使用</h3><p>由于该结构比较简单，我们直接来看看是如何使用的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> SADD books java</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD books java    <span class="comment"># 重复</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD books python golang</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SMEMBERS books    <span class="comment"># 注意顺序，set 是无序的 </span></span></span><br><span class="line">1) "java"</span><br><span class="line">2) "python"</span><br><span class="line">3) "golang"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SISMEMBER books java    <span class="comment"># 查询某个 value 是否存在，相当于 contains</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SCARD books    <span class="comment"># 获取长度</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SPOP books     <span class="comment"># 弹出一个</span></span></span><br><span class="line">"java"</span><br></pre></td></tr></table></figure>

<h2 id="5）有序列表-zset"><a href="#5）有序列表-zset" class="headerlink" title="5）有序列表 zset"></a>5）有序列表 zset</h2><p>这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p>
<p>它的内部实现用的是一种叫做 <strong>「跳跃表」</strong> 的数据结构，由于比较复杂，所以在这里简单提一下原理就好了：</p>
<p><a href="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis（1）——5种基本数据结构/7896890-efd5114939a651ed.png" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226112911.png" alt="img"></a></p>
<p>想象你是一家创业公司的老板，刚开始只有几个人，大家都平起平坐。后来随着公司的发展，人数越来越多，团队沟通成本逐渐增加，渐渐地引入了组长制，对团队进行划分，于是有一些人<strong>又是员工又有组长的身份</strong>。</p>
<p>再后来，公司规模进一步扩大，公司需要再进入一个层级：部门。于是每个部门又会从组长中推举一位选出部长。</p>
<p>跳跃表就类似于这样的机制，最下面一层所有的元素都会串起来，都是员工，然后每隔几个元素就会挑选出一个代表，再把这几个代表使用另外一级指针串起来。然后再在这些代表里面挑出二级代表，再串起来。<strong>最终形成了一个金字塔的结构。</strong></p>
<p>想一下你目前所在的地理位置：亚洲 &gt; 中国 &gt; 某省 &gt; 某市 &gt; ….，<strong>就是这样一个结构！</strong></p>
<h3 id="有序列表-zset-基础操作"><a href="#有序列表-zset-基础操作" class="headerlink" title="有序列表 zset 基础操作"></a>有序列表 zset 基础操作</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">COPY&gt;</span><span class="bash"> ZADD books 9.0 <span class="string">"think in java"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD books 8.9 <span class="string">"java concurrency"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD books 8.6 <span class="string">"java cookbook"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGE books 0 -1     <span class="comment"># 按 score 排序列出，参数区间为排名范围</span></span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "java concurrency"</span><br><span class="line">3) "think in java"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREVRANGE books 0 -1  <span class="comment"># 按 score 逆序列出，参数区间为排名范围</span></span></span><br><span class="line">1) "think in java"</span><br><span class="line">2) "java concurrency"</span><br><span class="line">3) "java cookbook"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZCARD books           <span class="comment"># 相当于 count()</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZSCORE books <span class="string">"java concurrency"</span>   <span class="comment"># 获取指定 value 的 score</span></span></span><br><span class="line">"8.9000000000000004"                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANK books <span class="string">"java concurrency"</span>    <span class="comment"># 排名</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGEBYSCORE books 0 8.91        <span class="comment"># 根据分值区间遍历 zset</span></span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "java concurrency"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGEBYSCORE books -inf 8.91 withscores  <span class="comment"># 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。</span></span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "8.5999999999999996"</span><br><span class="line">3) "java concurrency"</span><br><span class="line">4) "8.9000000000000004"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREM books <span class="string">"java concurrency"</span>             <span class="comment"># 删除 value</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGE books 0 -1</span></span><br><span class="line">1) "java cookbook"</span><br><span class="line">2) "think in java"</span><br></pre></td></tr></table></figure>

<h1 id="扩展-相关阅读"><a href="#扩展-相关阅读" class="headerlink" title="扩展/相关阅读"></a>扩展/相关阅读</h1><ol>
<li>阿里云 Redis 开发规范 - <a href="https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px" target="_blank" rel="noopener">https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px</a></li>
<li>为什么要防止 bigkey？ - <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;mid=2247483677&amp;idx=1&amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;mid=2247483677&amp;idx=1&amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;scene=21#wechat_redirect</a></li>
<li>Redis【入门】就这一篇！ - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/" target="_blank" rel="noopener">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 设计与实现》 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></li>
<li>【官方文档】Redis 数据类型介绍 - <a href="http://www.redis.cn/topics/data-types-intro.html" target="_blank" rel="noopener">http://www.redis.cn/topics/data-types-intro.html</a></li>
<li>《Redis 深度历险》 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>阿里云 Redis 开发规范 - <a href="https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px" target="_blank" rel="noopener">https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px</a></li>
<li>Redis 快速入门 - 易百教程 - <a href="https://www.yiibai.com/redis/redis_quick_guide.html" target="_blank" rel="noopener">https://www.yiibai.com/redis/redis_quick_guide.html</a></li>
<li>Redis【入门】就这一篇! - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/" target="_blank" rel="noopener">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">NicZSAMA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gakkisama.com/2020/07/09/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">http://gakkisama.com/2020/07/09/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gakkisama.com" target="_blank">o.0</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20210226113253.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/10/Netty/"><img class="prev-cover" src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200710110543.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">I/O 和 Netty</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/05/Dubbo/"><img class="next-cover" src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200723224858.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dubbo</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">NicZSAMA</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Redis-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、Redis 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">Redis 的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%9C%AC%E5%9C%B0-Redis-%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.</span> <span class="toc-text">测试本地 Redis 性能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redis-%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、Redis 五种基本数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2-string"><span class="toc-number">2.1.</span> <span class="toc-text">1）字符串 string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS-%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">SDS 的优化策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">对字符串的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">设置和获取键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">批量设置键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%92%8C-SET-%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">过期和 SET 命令扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%8E%9F%E5%80%BC%E7%9A%84-GETSET-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">返回原值的 GETSET 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89%E5%88%97%E8%A1%A8-list"><span class="toc-number">2.2.</span> <span class="toc-text">2）列表 list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">链表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">list 实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">list 实现栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%89%E5%AD%97%E5%85%B8-hash"><span class="toc-number">2.3.</span> <span class="toc-text">3）字典 hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash"><span class="toc-number">2.3.1.</span> <span class="toc-text">渐进式 rehash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E7%BC%A9%E5%AE%B9%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">扩缩容的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.</span> <span class="toc-text">字典的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89%E9%9B%86%E5%90%88-set"><span class="toc-number">2.4.</span> <span class="toc-text">4）集合 set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88-set-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">集合 set 的基本使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%89%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8-zset"><span class="toc-number">2.5.</span> <span class="toc-text">5）有序列表 zset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8-zset-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.1.</span> <span class="toc-text">有序列表 zset 基础操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB"><span class="toc-number">3.</span> <span class="toc-text">扩展&#x2F;相关阅读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D/" title="无题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2021/04/30/%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D/" title="无题">无题</a><time datetime="2021-04-30T01:54:40.159Z" title="发表于 2021-04-30 09:54:40">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务及解决方案"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式事务及解决方案"/></a><div class="content"><a class="title" href="/2021/03/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式事务及解决方案">分布式事务及解决方案</a><time datetime="2021-03-09T04:55:29.576Z" title="发表于 2021-03-09 12:55:29">2021-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/02/26/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="加密算法"/></a><div class="content"><a class="title" href="/2021/02/26/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法">加密算法</a><time datetime="2021-02-26T04:12:48.622Z" title="发表于 2021-02-26 12:12:48">2021-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/09/Jsoup%E5%A4%84%E7%90%86XSS%E6%94%BB%E5%87%BB/" title="Jsoup"><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200728142021.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Jsoup"/></a><div class="content"><a class="title" href="/2020/12/09/Jsoup%E5%A4%84%E7%90%86XSS%E6%94%BB%E5%87%BB/" title="Jsoup">Jsoup</a><time datetime="2020-12-09T04:57:11.708Z" title="发表于 2020-12-09 12:57:11">2020-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/29/Java%208%20%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%20/" title="Java 8 中的日期处理"><img src="https://nicspichost.oss-cn-beijing.aliyuncs.com/blog/20200728142021.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 8 中的日期处理"/></a><div class="content"><a class="title" href="/2020/07/29/Java%208%20%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%20/" title="Java 8 中的日期处理">Java 8 中的日期处理</a><time datetime="2020-07-29T02:52:58.638Z" title="发表于 2020-07-29 10:52:58">2020-07-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By NicZSAMA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>